{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.createTranspilingRequire = createTranspilingRequire;\nexports.default = void 0;\n\nfunction _crypto() {\n  const data = require('crypto');\n\n  _crypto = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _core() {\n  const data = require('@babel/core');\n\n  _core = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _babelPluginIstanbul() {\n  const data = _interopRequireDefault(require('babel-plugin-istanbul'));\n\n  _babelPluginIstanbul = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _convertSourceMap() {\n  const data = require('convert-source-map');\n\n  _convertSourceMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fastJsonStableStringify() {\n  const data = _interopRequireDefault(require('fast-json-stable-stringify'));\n\n  _fastJsonStableStringify = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _pirates() {\n  const data = require('pirates');\n\n  _pirates = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _slash() {\n  const data = _interopRequireDefault(require('slash'));\n\n  _slash = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _writeFileAtomic() {\n  const data = require('write-file-atomic');\n\n  _writeFileAtomic = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestHasteMap() {\n  const data = _interopRequireDefault(require('jest-haste-map'));\n\n  _jestHasteMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _enhanceUnexpectedTokenMessage = _interopRequireDefault(require('./enhanceUnexpectedTokenMessage'));\n\nvar _shouldInstrument = _interopRequireDefault(require('./shouldInstrument'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // Use `require` to avoid TS rootDir\n\n\nconst {\n  version: VERSION\n} = require('../package.json'); // This data structure is used to avoid recalculating some data every time that\n// we need to transform a file. Since ScriptTransformer is instantiated for each\n// file we need to keep this object in the local scope of this module.\n\n\nconst projectCaches = new Map(); // To reset the cache for specific changesets (rather than package version).\n\nconst CACHE_VERSION = '1';\n\nasync function waitForPromiseWithCleanup(promise, cleanup) {\n  try {\n    await promise;\n  } finally {\n    cleanup();\n  }\n}\n\nclass ScriptTransformer {\n  constructor(config) {\n    _defineProperty(this, '_cache', void 0);\n\n    _defineProperty(this, '_config', void 0);\n\n    _defineProperty(this, '_transformCache', void 0);\n\n    _defineProperty(this, '_transformConfigCache', void 0);\n\n    this._config = config;\n    this._transformCache = new Map();\n    this._transformConfigCache = new Map();\n    const configString = (0, _fastJsonStableStringify().default)(this._config);\n    let projectCache = projectCaches.get(configString);\n\n    if (!projectCache) {\n      projectCache = {\n        configString,\n        ignorePatternsRegExp: calcIgnorePatternRegExp(this._config),\n        transformRegExp: calcTransformRegExp(this._config),\n        transformedFiles: new Map()\n      };\n      projectCaches.set(configString, projectCache);\n    }\n\n    this._cache = projectCache;\n  }\n\n  _getCacheKey(fileData, filename, instrument, supportsDynamicImport, supportsStaticESM) {\n    const configString = this._cache.configString;\n\n    const transformer = this._getTransformer(filename);\n\n    if (transformer && typeof transformer.getCacheKey === 'function') {\n      return (0, _crypto().createHash)('md5').update(transformer.getCacheKey(fileData, filename, configString, {\n        config: this._config,\n        instrument,\n        rootDir: this._config.rootDir,\n        supportsDynamicImport,\n        supportsStaticESM\n      })).update(CACHE_VERSION).digest('hex');\n    } else {\n      return (0, _crypto().createHash)('md5').update(fileData).update(configString).update(instrument ? 'instrument' : '').update(filename).update(CACHE_VERSION).digest('hex');\n    }\n  }\n\n  _getFileCachePath(filename, content, instrument, supportsDynamicImport, supportsStaticESM) {\n    const baseCacheDir = _jestHasteMap().default.getCacheFilePath(this._config.cacheDirectory, 'jest-transform-cache-' + this._config.name, VERSION);\n\n    const cacheKey = this._getCacheKey(content, filename, instrument, supportsDynamicImport, supportsStaticESM); // Create sub folders based on the cacheKey to avoid creating one\n    // directory with many files.\n\n\n    const cacheDir = path().join(baseCacheDir, cacheKey[0] + cacheKey[1]);\n    const cacheFilenamePrefix = path().basename(filename, path().extname(filename)).replace(/\\W/g, '');\n    const cachePath = (0, _slash().default)(path().join(cacheDir, cacheFilenamePrefix + '_' + cacheKey));\n    (0, _jestUtil().createDirectory)(cacheDir);\n    return cachePath;\n  }\n\n  _getTransformPath(filename) {\n    const transformRegExp = this._cache.transformRegExp;\n\n    if (!transformRegExp) {\n      return undefined;\n    }\n\n    for (let i = 0; i < transformRegExp.length; i++) {\n      if (transformRegExp[i][0].test(filename)) {\n        const transformPath = transformRegExp[i][1];\n\n        this._transformConfigCache.set(transformPath, transformRegExp[i][2]);\n\n        return transformPath;\n      }\n    }\n\n    return undefined;\n  }\n\n  _getTransformer(filename) {\n    if (!this._config.transform || !this._config.transform.length) {\n      return null;\n    }\n\n    const transformPath = this._getTransformPath(filename);\n\n    if (!transformPath) {\n      return null;\n    }\n\n    const transformer = this._transformCache.get(transformPath);\n\n    if (transformer) {\n      return transformer;\n    }\n\n    let transform = require(transformPath);\n\n    if (!transform) {\n      throw new TypeError('Jest: a transform must export something.');\n    }\n\n    const transformerConfig = this._transformConfigCache.get(transformPath);\n\n    if (typeof transform.createTransformer === 'function') {\n      transform = transform.createTransformer(transformerConfig);\n    }\n\n    if (typeof transform.process !== 'function') {\n      throw new TypeError('Jest: a transform must export a `process` function.');\n    }\n\n    this._transformCache.set(transformPath, transform);\n\n    return transform;\n  }\n\n  _instrumentFile(filename, input, supportsDynamicImport, supportsStaticESM, canMapToInput) {\n    const inputCode = typeof input === 'string' ? input : input.code;\n    const inputMap = typeof input === 'string' ? null : input.map;\n    const result = (0, _core().transformSync)(inputCode, {\n      auxiliaryCommentBefore: ' istanbul ignore next ',\n      babelrc: false,\n      caller: {\n        name: '@jest/transform',\n        supportsDynamicImport,\n        supportsStaticESM\n      },\n      configFile: false,\n      filename,\n      plugins: [[_babelPluginIstanbul().default, {\n        compact: false,\n        // files outside `cwd` will not be instrumented\n        cwd: this._config.rootDir,\n        exclude: [],\n        extension: false,\n        inputSourceMap: inputMap,\n        useInlineSourceMaps: false\n      }]],\n      sourceMaps: canMapToInput ? 'both' : false\n    });\n\n    if (result && result.code) {\n      return result;\n    }\n\n    return input;\n  } // We don't want to expose transformers to the outside - this function is just\n  // to warm up `this._transformCache`\n\n\n  preloadTransformer(filepath) {\n    this._getTransformer(filepath);\n  } // TODO: replace third argument with TransformOptions in Jest 26\n\n\n  transformSource(filepath, content, instrument, supportsDynamicImport = false, supportsStaticESM = false) {\n    const filename = (0, _jestUtil().tryRealpath)(filepath);\n\n    const transform = this._getTransformer(filename);\n\n    const cacheFilePath = this._getFileCachePath(filename, content, instrument, supportsDynamicImport, supportsStaticESM);\n\n    let sourceMapPath = cacheFilePath + '.map'; // Ignore cache if `config.cache` is set (--no-cache)\n\n    let code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;\n    const shouldCallTransform = transform && this.shouldTransform(filename); // That means that the transform has a custom instrumentation\n    // logic and will handle it based on `config.collectCoverage` option\n\n    const transformWillInstrument = shouldCallTransform && transform && transform.canInstrument;\n\n    if (code) {\n      // This is broken: we return the code, and a path for the source map\n      // directly from the cache. But, nothing ensures the source map actually\n      // matches that source code. They could have gotten out-of-sync in case\n      // two separate processes write concurrently to the same cache files.\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    }\n\n    let transformed = {\n      code: content,\n      map: null\n    };\n\n    if (transform && shouldCallTransform) {\n      const processed = transform.process(content, filename, this._config, {\n        instrument,\n        supportsDynamicImport,\n        supportsStaticESM\n      });\n\n      if (typeof processed === 'string') {\n        transformed.code = processed;\n      } else if (processed != null && typeof processed.code === 'string') {\n        transformed = processed;\n      } else {\n        throw new TypeError(\"Jest: a transform's `process` function must return a string, \" + 'or an object with `code` key containing this string.');\n      }\n    }\n\n    if (!transformed.map) {\n      try {\n        //Could be a potential freeze here.\n        //See: https://github.com/facebook/jest/pull/5177#discussion_r158883570\n        const inlineSourceMap = (0, _convertSourceMap().fromSource)(transformed.code);\n\n        if (inlineSourceMap) {\n          transformed.map = inlineSourceMap.toObject();\n        }\n      } catch {\n        const transformPath = this._getTransformPath(filename);\n\n        console.warn(`jest-transform: The source map produced for the file ${filename} ` + `by ${transformPath} was invalid. Proceeding without source ` + 'mapping for that file.');\n      }\n    } // Apply instrumentation to the code if necessary, keeping the instrumented code and new map\n\n\n    let map = transformed.map;\n\n    if (!transformWillInstrument && instrument) {\n      /**\n       * We can map the original source code to the instrumented code ONLY if\n       * - the process of transforming the code produced a source map e.g. ts-jest\n       * - we did not transform the source code\n       *\n       * Otherwise we cannot make any statements about how the instrumented code corresponds to the original code,\n       * and we should NOT emit any source maps\n       *\n       */\n      const shouldEmitSourceMaps = transform != null && map != null || transform == null;\n\n      const instrumented = this._instrumentFile(filename, transformed, supportsDynamicImport, supportsStaticESM, shouldEmitSourceMaps);\n\n      code = typeof instrumented === 'string' ? instrumented : instrumented.code;\n      map = typeof instrumented === 'string' ? null : instrumented.map;\n    } else {\n      code = transformed.code;\n    }\n\n    if (map) {\n      const sourceMapContent = typeof map === 'string' ? map : JSON.stringify(map);\n      writeCacheFile(sourceMapPath, sourceMapContent);\n    } else {\n      sourceMapPath = null;\n    }\n\n    writeCodeCacheFile(cacheFilePath, code);\n    return {\n      code,\n      originalCode: content,\n      sourceMapPath\n    };\n  }\n\n  _transformAndBuildScript(filename, options, instrument, fileSource) {\n    const {\n      isCoreModule,\n      isInternalModule,\n      supportsDynamicImport,\n      supportsStaticESM\n    } = options;\n    const content = stripShebang(fileSource || fs().readFileSync(filename, 'utf8'));\n    let code = content;\n    let sourceMapPath = null;\n    const willTransform = !isInternalModule && !isCoreModule && (this.shouldTransform(filename) || instrument);\n\n    try {\n      if (willTransform) {\n        const transformedSource = this.transformSource(filename, content, instrument, supportsDynamicImport, supportsStaticESM);\n        code = transformedSource.code;\n        sourceMapPath = transformedSource.sourceMapPath;\n      }\n\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    } catch (e) {\n      throw (0, _enhanceUnexpectedTokenMessage.default)(e);\n    }\n  }\n\n  transform(filename, options, fileSource) {\n    let scriptCacheKey = undefined;\n    let instrument = false;\n\n    if (!options.isCoreModule) {\n      instrument = options.coverageProvider === 'babel' && (0, _shouldInstrument.default)(filename, options, this._config);\n      scriptCacheKey = getScriptCacheKey(filename, instrument);\n\n      const result = this._cache.transformedFiles.get(scriptCacheKey);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    const result = this._transformAndBuildScript(filename, options, instrument, fileSource);\n\n    if (scriptCacheKey) {\n      this._cache.transformedFiles.set(scriptCacheKey, result);\n    }\n\n    return result;\n  }\n\n  transformJson(filename, options, fileSource) {\n    const {\n      isCoreModule,\n      isInternalModule,\n      supportsDynamicImport,\n      supportsStaticESM\n    } = options;\n    const willTransform = !isInternalModule && !isCoreModule && this.shouldTransform(filename);\n\n    if (willTransform) {\n      const {\n        code: transformedJsonSource\n      } = this.transformSource(filename, fileSource, false, supportsDynamicImport, supportsStaticESM);\n      return transformedJsonSource;\n    }\n\n    return fileSource;\n  }\n\n  requireAndTranspileModule(moduleName, callback) {\n    // Load the transformer to avoid a cycle where we need to load a\n    // transformer in order to transform it in the require hooks\n    this.preloadTransformer(moduleName);\n    let transforming = false;\n    const revertHook = (0, _pirates().addHook)((code, filename) => {\n      try {\n        transforming = true;\n        return (// we might wanna do `supportsDynamicImport` at some point\n          this.transformSource(filename, code, false, false, false).code || code\n        );\n      } finally {\n        transforming = false;\n      }\n    }, {\n      exts: this._config.moduleFileExtensions.map(ext => `.${ext}`),\n      ignoreNodeModules: false,\n      matcher: filename => {\n        if (transforming) {\n          // Don't transform any dependency required by the transformer itself\n          return false;\n        }\n\n        return this.shouldTransform(filename);\n      }\n    });\n\n    const module = require(moduleName);\n\n    if (!callback) {\n      revertHook();\n      return module;\n    }\n\n    try {\n      const cbResult = callback(module);\n\n      if ((0, _jestUtil().isPromise)(cbResult)) {\n        return waitForPromiseWithCleanup(cbResult, revertHook).then(() => module);\n      }\n    } finally {\n      revertHook();\n    }\n\n    return module;\n  }\n  /**\n   * @deprecated use `this.shouldTransform` instead\n   */\n  // @ts-expect-error: Unused and private - remove in Jest 25\n\n\n  _shouldTransform(filename) {\n    return this.shouldTransform(filename);\n  }\n\n  shouldTransform(filename) {\n    const ignoreRegexp = this._cache.ignorePatternsRegExp;\n    const isIgnored = ignoreRegexp ? ignoreRegexp.test(filename) : false;\n    return !!this._config.transform && !!this._config.transform.length && !isIgnored;\n  }\n\n} // TODO: do we need to define the generics twice?\n\n\nexports.default = ScriptTransformer;\n\nfunction createTranspilingRequire(config) {\n  const transformer = new ScriptTransformer(config);\n  return function requireAndTranspileModule(resolverPath, applyInteropRequireDefault = false) {\n    const transpiledModule = transformer.requireAndTranspileModule(resolverPath);\n    return applyInteropRequireDefault ? (0, _jestUtil().interopRequireDefault)(transpiledModule).default : transpiledModule;\n  };\n}\n\nconst removeFile = path => {\n  try {\n    fs().unlinkSync(path);\n  } catch {}\n};\n\nconst stripShebang = content => {\n  // If the file data starts with a shebang remove it. Leaves the empty line\n  // to keep stack trace line numbers correct.\n  if (content.startsWith('#!')) {\n    return content.replace(/^#!.*/, '');\n  } else {\n    return content;\n  }\n};\n/**\n * This is like `writeCacheFile` but with an additional sanity checksum. We\n * cannot use the same technique for source maps because we expose source map\n * cache file paths directly to callsites, with the expectation they can read\n * it right away. This is not a great system, because source map cache file\n * could get corrupted, out-of-sync, etc.\n */\n\n\nfunction writeCodeCacheFile(cachePath, code) {\n  const checksum = (0, _crypto().createHash)('md5').update(code).digest('hex');\n  writeCacheFile(cachePath, checksum + '\\n' + code);\n}\n/**\n * Read counterpart of `writeCodeCacheFile`. We verify that the content of the\n * file matches the checksum, in case some kind of corruption happened. This\n * could happen if an older version of `jest-runtime` writes non-atomically to\n * the same cache, for example.\n */\n\n\nfunction readCodeCacheFile(cachePath) {\n  const content = readCacheFile(cachePath);\n\n  if (content == null) {\n    return null;\n  }\n\n  const code = content.substr(33);\n  const checksum = (0, _crypto().createHash)('md5').update(code).digest('hex');\n\n  if (checksum === content.substr(0, 32)) {\n    return code;\n  }\n\n  return null;\n}\n/**\n * Writing to the cache atomically relies on 'rename' being atomic on most\n * file systems. Doing atomic write reduces the risk of corruption by avoiding\n * two processes to write to the same file at the same time. It also reduces\n * the risk of reading a file that's being overwritten at the same time.\n */\n\n\nconst writeCacheFile = (cachePath, fileData) => {\n  try {\n    (0, _writeFileAtomic().sync)(cachePath, fileData, {\n      encoding: 'utf8',\n      fsync: false\n    });\n  } catch (e) {\n    if (cacheWriteErrorSafeToIgnore(e, cachePath)) {\n      return;\n    }\n\n    e.message = 'jest: failed to cache transform results in: ' + cachePath + '\\nFailure message: ' + e.message;\n    removeFile(cachePath);\n    throw e;\n  }\n};\n/**\n * On Windows, renames are not atomic, leading to EPERM exceptions when two\n * processes attempt to rename to the same target file at the same time.\n * If the target file exists we can be reasonably sure another process has\n * legitimately won a cache write race and ignore the error.\n */\n\n\nconst cacheWriteErrorSafeToIgnore = (e, cachePath) => process.platform === 'win32' && e.code === 'EPERM' && fs().existsSync(cachePath);\n\nconst readCacheFile = cachePath => {\n  if (!fs().existsSync(cachePath)) {\n    return null;\n  }\n\n  let fileData;\n\n  try {\n    fileData = fs().readFileSync(cachePath, 'utf8');\n  } catch (e) {\n    e.message = 'jest: failed to read cache file: ' + cachePath + '\\nFailure message: ' + e.message;\n    removeFile(cachePath);\n    throw e;\n  }\n\n  if (fileData == null) {\n    // We must have somehow created the file but failed to write to it,\n    // let's delete it and retry.\n    removeFile(cachePath);\n  }\n\n  return fileData;\n};\n\nconst getScriptCacheKey = (filename, instrument) => {\n  const mtime = fs().statSync(filename).mtime;\n  return filename + '_' + mtime.getTime() + (instrument ? '_instrumented' : '');\n};\n\nconst calcIgnorePatternRegExp = config => {\n  if (!config.transformIgnorePatterns || config.transformIgnorePatterns.length === 0) {\n    return undefined;\n  }\n\n  return new RegExp(config.transformIgnorePatterns.join('|'));\n};\n\nconst calcTransformRegExp = config => {\n  if (!config.transform.length) {\n    return undefined;\n  }\n\n  const transformRegexp = [];\n\n  for (let i = 0; i < config.transform.length; i++) {\n    transformRegexp.push([new RegExp(config.transform[i][0]), config.transform[i][1], config.transform[i][2]]);\n  }\n\n  return transformRegexp;\n};","map":{"version":3,"sources":["F:/GreenTea-Lemon/React/coderwhyReact/我的代码/15_learn_hooks/node_modules/@jest/transform/build/ScriptTransformer.js"],"names":["Object","defineProperty","exports","value","createTranspilingRequire","default","_crypto","data","require","path","_interopRequireWildcard","_core","_babelPluginIstanbul","_interopRequireDefault","_convertSourceMap","_fastJsonStableStringify","fs","_pirates","_slash","_writeFileAtomic","_jestHasteMap","_jestUtil","_enhanceUnexpectedTokenMessage","_shouldInstrument","obj","__esModule","_getRequireWildcardCache","WeakMap","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_defineProperty","enumerable","configurable","writable","version","VERSION","projectCaches","Map","CACHE_VERSION","waitForPromiseWithCleanup","promise","cleanup","ScriptTransformer","constructor","config","_config","_transformCache","_transformConfigCache","configString","projectCache","ignorePatternsRegExp","calcIgnorePatternRegExp","transformRegExp","calcTransformRegExp","transformedFiles","_cache","_getCacheKey","fileData","filename","instrument","supportsDynamicImport","supportsStaticESM","transformer","_getTransformer","getCacheKey","createHash","update","rootDir","digest","_getFileCachePath","content","baseCacheDir","getCacheFilePath","cacheDirectory","name","cacheKey","cacheDir","join","cacheFilenamePrefix","basename","extname","replace","cachePath","createDirectory","_getTransformPath","undefined","i","length","test","transformPath","transform","TypeError","transformerConfig","createTransformer","process","_instrumentFile","input","canMapToInput","inputCode","code","inputMap","map","result","transformSync","auxiliaryCommentBefore","babelrc","caller","configFile","plugins","compact","cwd","exclude","extension","inputSourceMap","useInlineSourceMaps","sourceMaps","preloadTransformer","filepath","transformSource","tryRealpath","cacheFilePath","sourceMapPath","readCodeCacheFile","shouldCallTransform","shouldTransform","transformWillInstrument","canInstrument","originalCode","transformed","processed","inlineSourceMap","fromSource","toObject","console","warn","shouldEmitSourceMaps","instrumented","sourceMapContent","JSON","stringify","writeCacheFile","writeCodeCacheFile","_transformAndBuildScript","options","fileSource","isCoreModule","isInternalModule","stripShebang","readFileSync","willTransform","transformedSource","e","scriptCacheKey","coverageProvider","getScriptCacheKey","transformJson","transformedJsonSource","requireAndTranspileModule","moduleName","callback","transforming","revertHook","addHook","exts","moduleFileExtensions","ext","ignoreNodeModules","matcher","module","cbResult","isPromise","then","_shouldTransform","ignoreRegexp","isIgnored","resolverPath","applyInteropRequireDefault","transpiledModule","interopRequireDefault","removeFile","unlinkSync","startsWith","checksum","readCacheFile","substr","sync","encoding","fsync","cacheWriteErrorSafeToIgnore","message","platform","existsSync","mtime","statSync","getTime","transformIgnorePatterns","RegExp","transformRegexp","push"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,wBAAR,GAAmCA,wBAAnC;AACAF,OAAO,CAACG,OAAR,GAAkB,KAAK,CAAvB;;AAEA,SAASC,OAAT,GAAmB;AACjB,QAAMC,IAAI,GAAGC,OAAO,CAAC,QAAD,CAApB;;AAEAF,EAAAA,OAAO,GAAG,YAAY;AACpB,WAAOC,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASE,IAAT,GAAgB;AACd,QAAMF,IAAI,GAAGG,uBAAuB,CAACF,OAAO,CAAC,MAAD,CAAR,CAApC;;AAEAC,EAAAA,IAAI,GAAG,YAAY;AACjB,WAAOF,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASI,KAAT,GAAiB;AACf,QAAMJ,IAAI,GAAGC,OAAO,CAAC,aAAD,CAApB;;AAEAG,EAAAA,KAAK,GAAG,YAAY;AAClB,WAAOJ,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASK,oBAAT,GAAgC;AAC9B,QAAML,IAAI,GAAGM,sBAAsB,CAACL,OAAO,CAAC,uBAAD,CAAR,CAAnC;;AAEAI,EAAAA,oBAAoB,GAAG,YAAY;AACjC,WAAOL,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASO,iBAAT,GAA6B;AAC3B,QAAMP,IAAI,GAAGC,OAAO,CAAC,oBAAD,CAApB;;AAEAM,EAAAA,iBAAiB,GAAG,YAAY;AAC9B,WAAOP,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASQ,wBAAT,GAAoC;AAClC,QAAMR,IAAI,GAAGM,sBAAsB,CAACL,OAAO,CAAC,4BAAD,CAAR,CAAnC;;AAEAO,EAAAA,wBAAwB,GAAG,YAAY;AACrC,WAAOR,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASS,EAAT,GAAc;AACZ,QAAMT,IAAI,GAAGG,uBAAuB,CAACF,OAAO,CAAC,aAAD,CAAR,CAApC;;AAEAQ,EAAAA,EAAE,GAAG,YAAY;AACf,WAAOT,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASU,QAAT,GAAoB;AAClB,QAAMV,IAAI,GAAGC,OAAO,CAAC,SAAD,CAApB;;AAEAS,EAAAA,QAAQ,GAAG,YAAY;AACrB,WAAOV,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASW,MAAT,GAAkB;AAChB,QAAMX,IAAI,GAAGM,sBAAsB,CAACL,OAAO,CAAC,OAAD,CAAR,CAAnC;;AAEAU,EAAAA,MAAM,GAAG,YAAY;AACnB,WAAOX,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASY,gBAAT,GAA4B;AAC1B,QAAMZ,IAAI,GAAGC,OAAO,CAAC,mBAAD,CAApB;;AAEAW,EAAAA,gBAAgB,GAAG,YAAY;AAC7B,WAAOZ,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASa,aAAT,GAAyB;AACvB,QAAMb,IAAI,GAAGM,sBAAsB,CAACL,OAAO,CAAC,gBAAD,CAAR,CAAnC;;AAEAY,EAAAA,aAAa,GAAG,YAAY;AAC1B,WAAOb,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASc,SAAT,GAAqB;AACnB,QAAMd,IAAI,GAAGC,OAAO,CAAC,WAAD,CAApB;;AAEAa,EAAAA,SAAS,GAAG,YAAY;AACtB,WAAOd,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,IAAIe,8BAA8B,GAAGT,sBAAsB,CACzDL,OAAO,CAAC,iCAAD,CADkD,CAA3D;;AAIA,IAAIe,iBAAiB,GAAGV,sBAAsB,CAACL,OAAO,CAAC,oBAAD,CAAR,CAA9C;;AAEA,SAASK,sBAAT,CAAgCW,GAAhC,EAAqC;AACnC,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAACnB,IAAAA,OAAO,EAAEmB;AAAV,GAArC;AACD;;AAED,SAASE,wBAAT,GAAoC;AAClC,MAAI,OAAOC,OAAP,KAAmB,UAAvB,EAAmC,OAAO,IAAP;AACnC,MAAIC,KAAK,GAAG,IAAID,OAAJ,EAAZ;;AACAD,EAAAA,wBAAwB,GAAG,YAAY;AACrC,WAAOE,KAAP;AACD,GAFD;;AAGA,SAAOA,KAAP;AACD;;AAED,SAASlB,uBAAT,CAAiCc,GAAjC,EAAsC;AACpC,MAAIA,GAAG,IAAIA,GAAG,CAACC,UAAf,EAA2B;AACzB,WAAOD,GAAP;AACD;;AACD,MAAIA,GAAG,KAAK,IAAR,IAAiB,OAAOA,GAAP,KAAe,QAAf,IAA2B,OAAOA,GAAP,KAAe,UAA/D,EAA4E;AAC1E,WAAO;AAACnB,MAAAA,OAAO,EAAEmB;AAAV,KAAP;AACD;;AACD,MAAII,KAAK,GAAGF,wBAAwB,EAApC;;AACA,MAAIE,KAAK,IAAIA,KAAK,CAACC,GAAN,CAAUL,GAAV,CAAb,EAA6B;AAC3B,WAAOI,KAAK,CAACE,GAAN,CAAUN,GAAV,CAAP;AACD;;AACD,MAAIO,MAAM,GAAG,EAAb;AACA,MAAIC,qBAAqB,GACvBhC,MAAM,CAACC,cAAP,IAAyBD,MAAM,CAACiC,wBADlC;;AAEA,OAAK,IAAIC,GAAT,IAAgBV,GAAhB,EAAqB;AACnB,QAAIxB,MAAM,CAACmC,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCb,GAArC,EAA0CU,GAA1C,CAAJ,EAAoD;AAClD,UAAII,IAAI,GAAGN,qBAAqB,GAC5BhC,MAAM,CAACiC,wBAAP,CAAgCT,GAAhC,EAAqCU,GAArC,CAD4B,GAE5B,IAFJ;;AAGA,UAAII,IAAI,KAAKA,IAAI,CAACR,GAAL,IAAYQ,IAAI,CAACC,GAAtB,CAAR,EAAoC;AAClCvC,QAAAA,MAAM,CAACC,cAAP,CAAsB8B,MAAtB,EAA8BG,GAA9B,EAAmCI,IAAnC;AACD,OAFD,MAEO;AACLP,QAAAA,MAAM,CAACG,GAAD,CAAN,GAAcV,GAAG,CAACU,GAAD,CAAjB;AACD;AACF;AACF;;AACDH,EAAAA,MAAM,CAAC1B,OAAP,GAAiBmB,GAAjB;;AACA,MAAII,KAAJ,EAAW;AACTA,IAAAA,KAAK,CAACW,GAAN,CAAUf,GAAV,EAAeO,MAAf;AACD;;AACD,SAAOA,MAAP;AACD;;AAED,SAASS,eAAT,CAAyBhB,GAAzB,EAA8BU,GAA9B,EAAmC/B,KAAnC,EAA0C;AACxC,MAAI+B,GAAG,IAAIV,GAAX,EAAgB;AACdxB,IAAAA,MAAM,CAACC,cAAP,CAAsBuB,GAAtB,EAA2BU,GAA3B,EAAgC;AAC9B/B,MAAAA,KAAK,EAAEA,KADuB;AAE9BsC,MAAAA,UAAU,EAAE,IAFkB;AAG9BC,MAAAA,YAAY,EAAE,IAHgB;AAI9BC,MAAAA,QAAQ,EAAE;AAJoB,KAAhC;AAMD,GAPD,MAOO;AACLnB,IAAAA,GAAG,CAACU,GAAD,CAAH,GAAW/B,KAAX;AACD;;AACD,SAAOqB,GAAP;AACD,C,CAED;;;AACA,MAAM;AAACoB,EAAAA,OAAO,EAAEC;AAAV,IAAqBrC,OAAO,CAAC,iBAAD,CAAlC,C,CAEA;AACA;AACA;;;AACA,MAAMsC,aAAa,GAAG,IAAIC,GAAJ,EAAtB,C,CAAiC;;AAEjC,MAAMC,aAAa,GAAG,GAAtB;;AAEA,eAAeC,yBAAf,CAAyCC,OAAzC,EAAkDC,OAAlD,EAA2D;AACzD,MAAI;AACF,UAAMD,OAAN;AACD,GAFD,SAEU;AACRC,IAAAA,OAAO;AACR;AACF;;AAED,MAAMC,iBAAN,CAAwB;AACtBC,EAAAA,WAAW,CAACC,MAAD,EAAS;AAClBd,IAAAA,eAAe,CAAC,IAAD,EAAO,QAAP,EAAiB,KAAK,CAAtB,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,SAAP,EAAkB,KAAK,CAAvB,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,iBAAP,EAA0B,KAAK,CAA/B,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,uBAAP,EAAgC,KAAK,CAArC,CAAf;;AAEA,SAAKe,OAAL,GAAeD,MAAf;AACA,SAAKE,eAAL,GAAuB,IAAIT,GAAJ,EAAvB;AACA,SAAKU,qBAAL,GAA6B,IAAIV,GAAJ,EAA7B;AACA,UAAMW,YAAY,GAAG,CAAC,GAAG3C,wBAAwB,GAAGV,OAA/B,EAAwC,KAAKkD,OAA7C,CAArB;AACA,QAAII,YAAY,GAAGb,aAAa,CAAChB,GAAd,CAAkB4B,YAAlB,CAAnB;;AAEA,QAAI,CAACC,YAAL,EAAmB;AACjBA,MAAAA,YAAY,GAAG;AACbD,QAAAA,YADa;AAEbE,QAAAA,oBAAoB,EAAEC,uBAAuB,CAAC,KAAKN,OAAN,CAFhC;AAGbO,QAAAA,eAAe,EAAEC,mBAAmB,CAAC,KAAKR,OAAN,CAHvB;AAIbS,QAAAA,gBAAgB,EAAE,IAAIjB,GAAJ;AAJL,OAAf;AAMAD,MAAAA,aAAa,CAACP,GAAd,CAAkBmB,YAAlB,EAAgCC,YAAhC;AACD;;AAED,SAAKM,MAAL,GAAcN,YAAd;AACD;;AAEDO,EAAAA,YAAY,CACVC,QADU,EAEVC,QAFU,EAGVC,UAHU,EAIVC,qBAJU,EAKVC,iBALU,EAMV;AACA,UAAMb,YAAY,GAAG,KAAKO,MAAL,CAAYP,YAAjC;;AAEA,UAAMc,WAAW,GAAG,KAAKC,eAAL,CAAqBL,QAArB,CAApB;;AAEA,QAAII,WAAW,IAAI,OAAOA,WAAW,CAACE,WAAnB,KAAmC,UAAtD,EAAkE;AAChE,aAAO,CAAC,GAAGpE,OAAO,GAAGqE,UAAd,EAA0B,KAA1B,EACJC,MADI,CAEHJ,WAAW,CAACE,WAAZ,CAAwBP,QAAxB,EAAkCC,QAAlC,EAA4CV,YAA5C,EAA0D;AACxDJ,QAAAA,MAAM,EAAE,KAAKC,OAD2C;AAExDc,QAAAA,UAFwD;AAGxDQ,QAAAA,OAAO,EAAE,KAAKtB,OAAL,CAAasB,OAHkC;AAIxDP,QAAAA,qBAJwD;AAKxDC,QAAAA;AALwD,OAA1D,CAFG,EAUJK,MAVI,CAUG5B,aAVH,EAWJ8B,MAXI,CAWG,KAXH,CAAP;AAYD,KAbD,MAaO;AACL,aAAO,CAAC,GAAGxE,OAAO,GAAGqE,UAAd,EAA0B,KAA1B,EACJC,MADI,CACGT,QADH,EAEJS,MAFI,CAEGlB,YAFH,EAGJkB,MAHI,CAGGP,UAAU,GAAG,YAAH,GAAkB,EAH/B,EAIJO,MAJI,CAIGR,QAJH,EAKJQ,MALI,CAKG5B,aALH,EAMJ8B,MANI,CAMG,KANH,CAAP;AAOD;AACF;;AAEDC,EAAAA,iBAAiB,CACfX,QADe,EAEfY,OAFe,EAGfX,UAHe,EAIfC,qBAJe,EAKfC,iBALe,EAMf;AACA,UAAMU,YAAY,GAAG7D,aAAa,GAAGf,OAAhB,CAAwB6E,gBAAxB,CACnB,KAAK3B,OAAL,CAAa4B,cADM,EAEnB,0BAA0B,KAAK5B,OAAL,CAAa6B,IAFpB,EAGnBvC,OAHmB,CAArB;;AAMA,UAAMwC,QAAQ,GAAG,KAAKnB,YAAL,CACfc,OADe,EAEfZ,QAFe,EAGfC,UAHe,EAIfC,qBAJe,EAKfC,iBALe,CAAjB,CAPA,CAaG;AACH;;;AAEA,UAAMe,QAAQ,GAAG7E,IAAI,GAAG8E,IAAP,CAAYN,YAAZ,EAA0BI,QAAQ,CAAC,CAAD,CAAR,GAAcA,QAAQ,CAAC,CAAD,CAAhD,CAAjB;AACA,UAAMG,mBAAmB,GAAG/E,IAAI,GAC7BgF,QADyB,CAChBrB,QADgB,EACN3D,IAAI,GAAGiF,OAAP,CAAetB,QAAf,CADM,EAEzBuB,OAFyB,CAEjB,KAFiB,EAEV,EAFU,CAA5B;AAGA,UAAMC,SAAS,GAAG,CAAC,GAAG1E,MAAM,GAAGb,OAAb,EAChBI,IAAI,GAAG8E,IAAP,CAAYD,QAAZ,EAAsBE,mBAAmB,GAAG,GAAtB,GAA4BH,QAAlD,CADgB,CAAlB;AAGA,KAAC,GAAGhE,SAAS,GAAGwE,eAAhB,EAAiCP,QAAjC;AACA,WAAOM,SAAP;AACD;;AAEDE,EAAAA,iBAAiB,CAAC1B,QAAD,EAAW;AAC1B,UAAMN,eAAe,GAAG,KAAKG,MAAL,CAAYH,eAApC;;AAEA,QAAI,CAACA,eAAL,EAAsB;AACpB,aAAOiC,SAAP;AACD;;AAED,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlC,eAAe,CAACmC,MAApC,EAA4CD,CAAC,EAA7C,EAAiD;AAC/C,UAAIlC,eAAe,CAACkC,CAAD,CAAf,CAAmB,CAAnB,EAAsBE,IAAtB,CAA2B9B,QAA3B,CAAJ,EAA0C;AACxC,cAAM+B,aAAa,GAAGrC,eAAe,CAACkC,CAAD,CAAf,CAAmB,CAAnB,CAAtB;;AAEA,aAAKvC,qBAAL,CAA2BlB,GAA3B,CAA+B4D,aAA/B,EAA8CrC,eAAe,CAACkC,CAAD,CAAf,CAAmB,CAAnB,CAA9C;;AAEA,eAAOG,aAAP;AACD;AACF;;AAED,WAAOJ,SAAP;AACD;;AAEDtB,EAAAA,eAAe,CAACL,QAAD,EAAW;AACxB,QAAI,CAAC,KAAKb,OAAL,CAAa6C,SAAd,IAA2B,CAAC,KAAK7C,OAAL,CAAa6C,SAAb,CAAuBH,MAAvD,EAA+D;AAC7D,aAAO,IAAP;AACD;;AAED,UAAME,aAAa,GAAG,KAAKL,iBAAL,CAAuB1B,QAAvB,CAAtB;;AAEA,QAAI,CAAC+B,aAAL,EAAoB;AAClB,aAAO,IAAP;AACD;;AAED,UAAM3B,WAAW,GAAG,KAAKhB,eAAL,CAAqB1B,GAArB,CAAyBqE,aAAzB,CAApB;;AAEA,QAAI3B,WAAJ,EAAiB;AACf,aAAOA,WAAP;AACD;;AAED,QAAI4B,SAAS,GAAG5F,OAAO,CAAC2F,aAAD,CAAvB;;AAEA,QAAI,CAACC,SAAL,EAAgB;AACd,YAAM,IAAIC,SAAJ,CAAc,0CAAd,CAAN;AACD;;AAED,UAAMC,iBAAiB,GAAG,KAAK7C,qBAAL,CAA2B3B,GAA3B,CAA+BqE,aAA/B,CAA1B;;AAEA,QAAI,OAAOC,SAAS,CAACG,iBAAjB,KAAuC,UAA3C,EAAuD;AACrDH,MAAAA,SAAS,GAAGA,SAAS,CAACG,iBAAV,CAA4BD,iBAA5B,CAAZ;AACD;;AAED,QAAI,OAAOF,SAAS,CAACI,OAAjB,KAA6B,UAAjC,EAA6C;AAC3C,YAAM,IAAIH,SAAJ,CACJ,qDADI,CAAN;AAGD;;AAED,SAAK7C,eAAL,CAAqBjB,GAArB,CAAyB4D,aAAzB,EAAwCC,SAAxC;;AAEA,WAAOA,SAAP;AACD;;AAEDK,EAAAA,eAAe,CACbrC,QADa,EAEbsC,KAFa,EAGbpC,qBAHa,EAIbC,iBAJa,EAKboC,aALa,EAMb;AACA,UAAMC,SAAS,GAAG,OAAOF,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoCA,KAAK,CAACG,IAA5D;AACA,UAAMC,QAAQ,GAAG,OAAOJ,KAAP,KAAiB,QAAjB,GAA4B,IAA5B,GAAmCA,KAAK,CAACK,GAA1D;AACA,UAAMC,MAAM,GAAG,CAAC,GAAGrG,KAAK,GAAGsG,aAAZ,EAA2BL,SAA3B,EAAsC;AACnDM,MAAAA,sBAAsB,EAAE,wBAD2B;AAEnDC,MAAAA,OAAO,EAAE,KAF0C;AAGnDC,MAAAA,MAAM,EAAE;AACNhC,QAAAA,IAAI,EAAE,iBADA;AAENd,QAAAA,qBAFM;AAGNC,QAAAA;AAHM,OAH2C;AAQnD8C,MAAAA,UAAU,EAAE,KARuC;AASnDjD,MAAAA,QATmD;AAUnDkD,MAAAA,OAAO,EAAE,CACP,CACE1G,oBAAoB,GAAGP,OADzB,EAEE;AACEkH,QAAAA,OAAO,EAAE,KADX;AAEE;AACAC,QAAAA,GAAG,EAAE,KAAKjE,OAAL,CAAasB,OAHpB;AAIE4C,QAAAA,OAAO,EAAE,EAJX;AAKEC,QAAAA,SAAS,EAAE,KALb;AAMEC,QAAAA,cAAc,EAAEb,QANlB;AAOEc,QAAAA,mBAAmB,EAAE;AAPvB,OAFF,CADO,CAV0C;AAwBnDC,MAAAA,UAAU,EAAElB,aAAa,GAAG,MAAH,GAAY;AAxBc,KAAtC,CAAf;;AA2BA,QAAIK,MAAM,IAAIA,MAAM,CAACH,IAArB,EAA2B;AACzB,aAAOG,MAAP;AACD;;AAED,WAAON,KAAP;AACD,GAtMqB,CAsMpB;AACF;;;AAEAoB,EAAAA,kBAAkB,CAACC,QAAD,EAAW;AAC3B,SAAKtD,eAAL,CAAqBsD,QAArB;AACD,GA3MqB,CA2MpB;;;AAEFC,EAAAA,eAAe,CACbD,QADa,EAEb/C,OAFa,EAGbX,UAHa,EAIbC,qBAAqB,GAAG,KAJX,EAKbC,iBAAiB,GAAG,KALP,EAMb;AACA,UAAMH,QAAQ,GAAG,CAAC,GAAG/C,SAAS,GAAG4G,WAAhB,EAA6BF,QAA7B,CAAjB;;AAEA,UAAM3B,SAAS,GAAG,KAAK3B,eAAL,CAAqBL,QAArB,CAAlB;;AAEA,UAAM8D,aAAa,GAAG,KAAKnD,iBAAL,CACpBX,QADoB,EAEpBY,OAFoB,EAGpBX,UAHoB,EAIpBC,qBAJoB,EAKpBC,iBALoB,CAAtB;;AAQA,QAAI4D,aAAa,GAAGD,aAAa,GAAG,MAApC,CAbA,CAa4C;;AAE5C,QAAIrB,IAAI,GAAG,KAAKtD,OAAL,CAAa3B,KAAb,GAAqBwG,iBAAiB,CAACF,aAAD,CAAtC,GAAwD,IAAnE;AACA,UAAMG,mBAAmB,GAAGjC,SAAS,IAAI,KAAKkC,eAAL,CAAqBlE,QAArB,CAAzC,CAhBA,CAgByE;AACzE;;AAEA,UAAMmE,uBAAuB,GAC3BF,mBAAmB,IAAIjC,SAAvB,IAAoCA,SAAS,CAACoC,aADhD;;AAGA,QAAI3B,IAAJ,EAAU;AACR;AACA;AACA;AACA;AACA,aAAO;AACLA,QAAAA,IADK;AAEL4B,QAAAA,YAAY,EAAEzD,OAFT;AAGLmD,QAAAA;AAHK,OAAP;AAKD;;AAED,QAAIO,WAAW,GAAG;AAChB7B,MAAAA,IAAI,EAAE7B,OADU;AAEhB+B,MAAAA,GAAG,EAAE;AAFW,KAAlB;;AAKA,QAAIX,SAAS,IAAIiC,mBAAjB,EAAsC;AACpC,YAAMM,SAAS,GAAGvC,SAAS,CAACI,OAAV,CAAkBxB,OAAlB,EAA2BZ,QAA3B,EAAqC,KAAKb,OAA1C,EAAmD;AACnEc,QAAAA,UADmE;AAEnEC,QAAAA,qBAFmE;AAGnEC,QAAAA;AAHmE,OAAnD,CAAlB;;AAMA,UAAI,OAAOoE,SAAP,KAAqB,QAAzB,EAAmC;AACjCD,QAAAA,WAAW,CAAC7B,IAAZ,GAAmB8B,SAAnB;AACD,OAFD,MAEO,IAAIA,SAAS,IAAI,IAAb,IAAqB,OAAOA,SAAS,CAAC9B,IAAjB,KAA0B,QAAnD,EAA6D;AAClE6B,QAAAA,WAAW,GAAGC,SAAd;AACD,OAFM,MAEA;AACL,cAAM,IAAItC,SAAJ,CACJ,kEACE,sDAFE,CAAN;AAID;AACF;;AAED,QAAI,CAACqC,WAAW,CAAC3B,GAAjB,EAAsB;AACpB,UAAI;AACF;AACA;AACA,cAAM6B,eAAe,GAAG,CAAC,GAAG9H,iBAAiB,GAAG+H,UAAxB,EACtBH,WAAW,CAAC7B,IADU,CAAxB;;AAIA,YAAI+B,eAAJ,EAAqB;AACnBF,UAAAA,WAAW,CAAC3B,GAAZ,GAAkB6B,eAAe,CAACE,QAAhB,EAAlB;AACD;AACF,OAVD,CAUE,MAAM;AACN,cAAM3C,aAAa,GAAG,KAAKL,iBAAL,CAAuB1B,QAAvB,CAAtB;;AAEA2E,QAAAA,OAAO,CAACC,IAAR,CACG,wDAAuD5E,QAAS,GAAjE,GACG,MAAK+B,aAAc,0CADtB,GAEE,wBAHJ;AAKD;AACF,KA9ED,CA8EE;;;AAEF,QAAIY,GAAG,GAAG2B,WAAW,CAAC3B,GAAtB;;AAEA,QAAI,CAACwB,uBAAD,IAA4BlE,UAAhC,EAA4C;AAC1C;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACM,YAAM4E,oBAAoB,GACvB7C,SAAS,IAAI,IAAb,IAAqBW,GAAG,IAAI,IAA7B,IAAsCX,SAAS,IAAI,IADrD;;AAGA,YAAM8C,YAAY,GAAG,KAAKzC,eAAL,CACnBrC,QADmB,EAEnBsE,WAFmB,EAGnBpE,qBAHmB,EAInBC,iBAJmB,EAKnB0E,oBALmB,CAArB;;AAQApC,MAAAA,IAAI,GACF,OAAOqC,YAAP,KAAwB,QAAxB,GAAmCA,YAAnC,GAAkDA,YAAY,CAACrC,IADjE;AAEAE,MAAAA,GAAG,GAAG,OAAOmC,YAAP,KAAwB,QAAxB,GAAmC,IAAnC,GAA0CA,YAAY,CAACnC,GAA7D;AACD,KAxBD,MAwBO;AACLF,MAAAA,IAAI,GAAG6B,WAAW,CAAC7B,IAAnB;AACD;;AAED,QAAIE,GAAJ,EAAS;AACP,YAAMoC,gBAAgB,GACpB,OAAOpC,GAAP,KAAe,QAAf,GAA0BA,GAA1B,GAAgCqC,IAAI,CAACC,SAAL,CAAetC,GAAf,CADlC;AAEAuC,MAAAA,cAAc,CAACnB,aAAD,EAAgBgB,gBAAhB,CAAd;AACD,KAJD,MAIO;AACLhB,MAAAA,aAAa,GAAG,IAAhB;AACD;;AAEDoB,IAAAA,kBAAkB,CAACrB,aAAD,EAAgBrB,IAAhB,CAAlB;AACA,WAAO;AACLA,MAAAA,IADK;AAEL4B,MAAAA,YAAY,EAAEzD,OAFT;AAGLmD,MAAAA;AAHK,KAAP;AAKD;;AAEDqB,EAAAA,wBAAwB,CAACpF,QAAD,EAAWqF,OAAX,EAAoBpF,UAApB,EAAgCqF,UAAhC,EAA4C;AAClE,UAAM;AACJC,MAAAA,YADI;AAEJC,MAAAA,gBAFI;AAGJtF,MAAAA,qBAHI;AAIJC,MAAAA;AAJI,QAKFkF,OALJ;AAMA,UAAMzE,OAAO,GAAG6E,YAAY,CAC1BH,UAAU,IAAI1I,EAAE,GAAG8I,YAAL,CAAkB1F,QAAlB,EAA4B,MAA5B,CADY,CAA5B;AAGA,QAAIyC,IAAI,GAAG7B,OAAX;AACA,QAAImD,aAAa,GAAG,IAApB;AACA,UAAM4B,aAAa,GACjB,CAACH,gBAAD,IACA,CAACD,YADD,KAEC,KAAKrB,eAAL,CAAqBlE,QAArB,KAAkCC,UAFnC,CADF;;AAKA,QAAI;AACF,UAAI0F,aAAJ,EAAmB;AACjB,cAAMC,iBAAiB,GAAG,KAAKhC,eAAL,CACxB5D,QADwB,EAExBY,OAFwB,EAGxBX,UAHwB,EAIxBC,qBAJwB,EAKxBC,iBALwB,CAA1B;AAOAsC,QAAAA,IAAI,GAAGmD,iBAAiB,CAACnD,IAAzB;AACAsB,QAAAA,aAAa,GAAG6B,iBAAiB,CAAC7B,aAAlC;AACD;;AAED,aAAO;AACLtB,QAAAA,IADK;AAEL4B,QAAAA,YAAY,EAAEzD,OAFT;AAGLmD,QAAAA;AAHK,OAAP;AAKD,KAlBD,CAkBE,OAAO8B,CAAP,EAAU;AACV,YAAM,CAAC,GAAG3I,8BAA8B,CAACjB,OAAnC,EAA4C4J,CAA5C,CAAN;AACD;AACF;;AAED7D,EAAAA,SAAS,CAAChC,QAAD,EAAWqF,OAAX,EAAoBC,UAApB,EAAgC;AACvC,QAAIQ,cAAc,GAAGnE,SAArB;AACA,QAAI1B,UAAU,GAAG,KAAjB;;AAEA,QAAI,CAACoF,OAAO,CAACE,YAAb,EAA2B;AACzBtF,MAAAA,UAAU,GACRoF,OAAO,CAACU,gBAAR,KAA6B,OAA7B,IACA,CAAC,GAAG5I,iBAAiB,CAAClB,OAAtB,EAA+B+D,QAA/B,EAAyCqF,OAAzC,EAAkD,KAAKlG,OAAvD,CAFF;AAGA2G,MAAAA,cAAc,GAAGE,iBAAiB,CAAChG,QAAD,EAAWC,UAAX,CAAlC;;AAEA,YAAM2C,MAAM,GAAG,KAAK/C,MAAL,CAAYD,gBAAZ,CAA6BlC,GAA7B,CAAiCoI,cAAjC,CAAf;;AAEA,UAAIlD,MAAJ,EAAY;AACV,eAAOA,MAAP;AACD;AACF;;AAED,UAAMA,MAAM,GAAG,KAAKwC,wBAAL,CACbpF,QADa,EAEbqF,OAFa,EAGbpF,UAHa,EAIbqF,UAJa,CAAf;;AAOA,QAAIQ,cAAJ,EAAoB;AAClB,WAAKjG,MAAL,CAAYD,gBAAZ,CAA6BzB,GAA7B,CAAiC2H,cAAjC,EAAiDlD,MAAjD;AACD;;AAED,WAAOA,MAAP;AACD;;AAEDqD,EAAAA,aAAa,CAACjG,QAAD,EAAWqF,OAAX,EAAoBC,UAApB,EAAgC;AAC3C,UAAM;AACJC,MAAAA,YADI;AAEJC,MAAAA,gBAFI;AAGJtF,MAAAA,qBAHI;AAIJC,MAAAA;AAJI,QAKFkF,OALJ;AAMA,UAAMM,aAAa,GACjB,CAACH,gBAAD,IAAqB,CAACD,YAAtB,IAAsC,KAAKrB,eAAL,CAAqBlE,QAArB,CADxC;;AAGA,QAAI2F,aAAJ,EAAmB;AACjB,YAAM;AAAClD,QAAAA,IAAI,EAAEyD;AAAP,UAAgC,KAAKtC,eAAL,CACpC5D,QADoC,EAEpCsF,UAFoC,EAGpC,KAHoC,EAIpCpF,qBAJoC,EAKpCC,iBALoC,CAAtC;AAOA,aAAO+F,qBAAP;AACD;;AAED,WAAOZ,UAAP;AACD;;AAEDa,EAAAA,yBAAyB,CAACC,UAAD,EAAaC,QAAb,EAAuB;AAC9C;AACA;AACA,SAAK3C,kBAAL,CAAwB0C,UAAxB;AACA,QAAIE,YAAY,GAAG,KAAnB;AACA,UAAMC,UAAU,GAAG,CAAC,GAAG1J,QAAQ,GAAG2J,OAAf,EACjB,CAAC/D,IAAD,EAAOzC,QAAP,KAAoB;AAClB,UAAI;AACFsG,QAAAA,YAAY,GAAG,IAAf;AACA,eACE;AACA,eAAK1C,eAAL,CAAqB5D,QAArB,EAA+ByC,IAA/B,EAAqC,KAArC,EAA4C,KAA5C,EAAmD,KAAnD,EAA0DA,IAA1D,IACAA;AAHF;AAKD,OAPD,SAOU;AACR6D,QAAAA,YAAY,GAAG,KAAf;AACD;AACF,KAZgB,EAajB;AACEG,MAAAA,IAAI,EAAE,KAAKtH,OAAL,CAAauH,oBAAb,CAAkC/D,GAAlC,CAAsCgE,GAAG,IAAK,IAAGA,GAAI,EAArD,CADR;AAEEC,MAAAA,iBAAiB,EAAE,KAFrB;AAGEC,MAAAA,OAAO,EAAE7G,QAAQ,IAAI;AACnB,YAAIsG,YAAJ,EAAkB;AAChB;AACA,iBAAO,KAAP;AACD;;AAED,eAAO,KAAKpC,eAAL,CAAqBlE,QAArB,CAAP;AACD;AAVH,KAbiB,CAAnB;;AA2BA,UAAM8G,MAAM,GAAG1K,OAAO,CAACgK,UAAD,CAAtB;;AAEA,QAAI,CAACC,QAAL,EAAe;AACbE,MAAAA,UAAU;AACV,aAAOO,MAAP;AACD;;AAED,QAAI;AACF,YAAMC,QAAQ,GAAGV,QAAQ,CAACS,MAAD,CAAzB;;AAEA,UAAI,CAAC,GAAG7J,SAAS,GAAG+J,SAAhB,EAA2BD,QAA3B,CAAJ,EAA0C;AACxC,eAAOlI,yBAAyB,CAACkI,QAAD,EAAWR,UAAX,CAAzB,CAAgDU,IAAhD,CACL,MAAMH,MADD,CAAP;AAGD;AACF,KARD,SAQU;AACRP,MAAAA,UAAU;AACX;;AAED,WAAOO,MAAP;AACD;AACD;AACF;AACA;AACE;;;AAEAI,EAAAA,gBAAgB,CAAClH,QAAD,EAAW;AACzB,WAAO,KAAKkE,eAAL,CAAqBlE,QAArB,CAAP;AACD;;AAEDkE,EAAAA,eAAe,CAAClE,QAAD,EAAW;AACxB,UAAMmH,YAAY,GAAG,KAAKtH,MAAL,CAAYL,oBAAjC;AACA,UAAM4H,SAAS,GAAGD,YAAY,GAAGA,YAAY,CAACrF,IAAb,CAAkB9B,QAAlB,CAAH,GAAiC,KAA/D;AACA,WACE,CAAC,CAAC,KAAKb,OAAL,CAAa6C,SAAf,IAA4B,CAAC,CAAC,KAAK7C,OAAL,CAAa6C,SAAb,CAAuBH,MAArD,IAA+D,CAACuF,SADlE;AAGD;;AApfqB,C,CAqftB;;;AAEFtL,OAAO,CAACG,OAAR,GAAkB+C,iBAAlB;;AAEA,SAAShD,wBAAT,CAAkCkD,MAAlC,EAA0C;AACxC,QAAMkB,WAAW,GAAG,IAAIpB,iBAAJ,CAAsBE,MAAtB,CAApB;AACA,SAAO,SAASiH,yBAAT,CACLkB,YADK,EAELC,0BAA0B,GAAG,KAFxB,EAGL;AACA,UAAMC,gBAAgB,GAAGnH,WAAW,CAAC+F,yBAAZ,CACvBkB,YADuB,CAAzB;AAGA,WAAOC,0BAA0B,GAC7B,CAAC,GAAGrK,SAAS,GAAGuK,qBAAhB,EAAuCD,gBAAvC,EAAyDtL,OAD5B,GAE7BsL,gBAFJ;AAGD,GAVD;AAWD;;AAED,MAAME,UAAU,GAAGpL,IAAI,IAAI;AACzB,MAAI;AACFO,IAAAA,EAAE,GAAG8K,UAAL,CAAgBrL,IAAhB;AACD,GAFD,CAEE,MAAM,CAAE;AACX,CAJD;;AAMA,MAAMoJ,YAAY,GAAG7E,OAAO,IAAI;AAC9B;AACA;AACA,MAAIA,OAAO,CAAC+G,UAAR,CAAmB,IAAnB,CAAJ,EAA8B;AAC5B,WAAO/G,OAAO,CAACW,OAAR,CAAgB,OAAhB,EAAyB,EAAzB,CAAP;AACD,GAFD,MAEO;AACL,WAAOX,OAAP;AACD;AACF,CARD;AASA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASuE,kBAAT,CAA4B3D,SAA5B,EAAuCiB,IAAvC,EAA6C;AAC3C,QAAMmF,QAAQ,GAAG,CAAC,GAAG1L,OAAO,GAAGqE,UAAd,EAA0B,KAA1B,EAAiCC,MAAjC,CAAwCiC,IAAxC,EAA8C/B,MAA9C,CAAqD,KAArD,CAAjB;AACAwE,EAAAA,cAAc,CAAC1D,SAAD,EAAYoG,QAAQ,GAAG,IAAX,GAAkBnF,IAA9B,CAAd;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASuB,iBAAT,CAA2BxC,SAA3B,EAAsC;AACpC,QAAMZ,OAAO,GAAGiH,aAAa,CAACrG,SAAD,CAA7B;;AAEA,MAAIZ,OAAO,IAAI,IAAf,EAAqB;AACnB,WAAO,IAAP;AACD;;AAED,QAAM6B,IAAI,GAAG7B,OAAO,CAACkH,MAAR,CAAe,EAAf,CAAb;AACA,QAAMF,QAAQ,GAAG,CAAC,GAAG1L,OAAO,GAAGqE,UAAd,EAA0B,KAA1B,EAAiCC,MAAjC,CAAwCiC,IAAxC,EAA8C/B,MAA9C,CAAqD,KAArD,CAAjB;;AAEA,MAAIkH,QAAQ,KAAKhH,OAAO,CAACkH,MAAR,CAAe,CAAf,EAAkB,EAAlB,CAAjB,EAAwC;AACtC,WAAOrF,IAAP;AACD;;AAED,SAAO,IAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMyC,cAAc,GAAG,CAAC1D,SAAD,EAAYzB,QAAZ,KAAyB;AAC9C,MAAI;AACF,KAAC,GAAGhD,gBAAgB,GAAGgL,IAAvB,EAA6BvG,SAA7B,EAAwCzB,QAAxC,EAAkD;AAChDiI,MAAAA,QAAQ,EAAE,MADsC;AAEhDC,MAAAA,KAAK,EAAE;AAFyC,KAAlD;AAID,GALD,CAKE,OAAOpC,CAAP,EAAU;AACV,QAAIqC,2BAA2B,CAACrC,CAAD,EAAIrE,SAAJ,CAA/B,EAA+C;AAC7C;AACD;;AAEDqE,IAAAA,CAAC,CAACsC,OAAF,GACE,iDACA3G,SADA,GAEA,qBAFA,GAGAqE,CAAC,CAACsC,OAJJ;AAKAV,IAAAA,UAAU,CAACjG,SAAD,CAAV;AACA,UAAMqE,CAAN;AACD;AACF,CAnBD;AAoBA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMqC,2BAA2B,GAAG,CAACrC,CAAD,EAAIrE,SAAJ,KAClCY,OAAO,CAACgG,QAAR,KAAqB,OAArB,IACAvC,CAAC,CAACpD,IAAF,KAAW,OADX,IAEA7F,EAAE,GAAGyL,UAAL,CAAgB7G,SAAhB,CAHF;;AAKA,MAAMqG,aAAa,GAAGrG,SAAS,IAAI;AACjC,MAAI,CAAC5E,EAAE,GAAGyL,UAAL,CAAgB7G,SAAhB,CAAL,EAAiC;AAC/B,WAAO,IAAP;AACD;;AAED,MAAIzB,QAAJ;;AAEA,MAAI;AACFA,IAAAA,QAAQ,GAAGnD,EAAE,GAAG8I,YAAL,CAAkBlE,SAAlB,EAA6B,MAA7B,CAAX;AACD,GAFD,CAEE,OAAOqE,CAAP,EAAU;AACVA,IAAAA,CAAC,CAACsC,OAAF,GACE,sCACA3G,SADA,GAEA,qBAFA,GAGAqE,CAAC,CAACsC,OAJJ;AAKAV,IAAAA,UAAU,CAACjG,SAAD,CAAV;AACA,UAAMqE,CAAN;AACD;;AAED,MAAI9F,QAAQ,IAAI,IAAhB,EAAsB;AACpB;AACA;AACA0H,IAAAA,UAAU,CAACjG,SAAD,CAAV;AACD;;AAED,SAAOzB,QAAP;AACD,CA1BD;;AA4BA,MAAMiG,iBAAiB,GAAG,CAAChG,QAAD,EAAWC,UAAX,KAA0B;AAClD,QAAMqI,KAAK,GAAG1L,EAAE,GAAG2L,QAAL,CAAcvI,QAAd,EAAwBsI,KAAtC;AACA,SAAOtI,QAAQ,GAAG,GAAX,GAAiBsI,KAAK,CAACE,OAAN,EAAjB,IAAoCvI,UAAU,GAAG,eAAH,GAAqB,EAAnE,CAAP;AACD,CAHD;;AAKA,MAAMR,uBAAuB,GAAGP,MAAM,IAAI;AACxC,MACE,CAACA,MAAM,CAACuJ,uBAAR,IACAvJ,MAAM,CAACuJ,uBAAP,CAA+B5G,MAA/B,KAA0C,CAF5C,EAGE;AACA,WAAOF,SAAP;AACD;;AAED,SAAO,IAAI+G,MAAJ,CAAWxJ,MAAM,CAACuJ,uBAAP,CAA+BtH,IAA/B,CAAoC,GAApC,CAAX,CAAP;AACD,CATD;;AAWA,MAAMxB,mBAAmB,GAAGT,MAAM,IAAI;AACpC,MAAI,CAACA,MAAM,CAAC8C,SAAP,CAAiBH,MAAtB,EAA8B;AAC5B,WAAOF,SAAP;AACD;;AAED,QAAMgH,eAAe,GAAG,EAAxB;;AAEA,OAAK,IAAI/G,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1C,MAAM,CAAC8C,SAAP,CAAiBH,MAArC,EAA6CD,CAAC,EAA9C,EAAkD;AAChD+G,IAAAA,eAAe,CAACC,IAAhB,CAAqB,CACnB,IAAIF,MAAJ,CAAWxJ,MAAM,CAAC8C,SAAP,CAAiBJ,CAAjB,EAAoB,CAApB,CAAX,CADmB,EAEnB1C,MAAM,CAAC8C,SAAP,CAAiBJ,CAAjB,EAAoB,CAApB,CAFmB,EAGnB1C,MAAM,CAAC8C,SAAP,CAAiBJ,CAAjB,EAAoB,CAApB,CAHmB,CAArB;AAKD;;AAED,SAAO+G,eAAP;AACD,CAhBD","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.createTranspilingRequire = createTranspilingRequire;\nexports.default = void 0;\n\nfunction _crypto() {\n  const data = require('crypto');\n\n  _crypto = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _core() {\n  const data = require('@babel/core');\n\n  _core = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _babelPluginIstanbul() {\n  const data = _interopRequireDefault(require('babel-plugin-istanbul'));\n\n  _babelPluginIstanbul = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _convertSourceMap() {\n  const data = require('convert-source-map');\n\n  _convertSourceMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fastJsonStableStringify() {\n  const data = _interopRequireDefault(require('fast-json-stable-stringify'));\n\n  _fastJsonStableStringify = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _pirates() {\n  const data = require('pirates');\n\n  _pirates = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _slash() {\n  const data = _interopRequireDefault(require('slash'));\n\n  _slash = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _writeFileAtomic() {\n  const data = require('write-file-atomic');\n\n  _writeFileAtomic = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestHasteMap() {\n  const data = _interopRequireDefault(require('jest-haste-map'));\n\n  _jestHasteMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _enhanceUnexpectedTokenMessage = _interopRequireDefault(\n  require('./enhanceUnexpectedTokenMessage')\n);\n\nvar _shouldInstrument = _interopRequireDefault(require('./shouldInstrument'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n// Use `require` to avoid TS rootDir\nconst {version: VERSION} = require('../package.json');\n\n// This data structure is used to avoid recalculating some data every time that\n// we need to transform a file. Since ScriptTransformer is instantiated for each\n// file we need to keep this object in the local scope of this module.\nconst projectCaches = new Map(); // To reset the cache for specific changesets (rather than package version).\n\nconst CACHE_VERSION = '1';\n\nasync function waitForPromiseWithCleanup(promise, cleanup) {\n  try {\n    await promise;\n  } finally {\n    cleanup();\n  }\n}\n\nclass ScriptTransformer {\n  constructor(config) {\n    _defineProperty(this, '_cache', void 0);\n\n    _defineProperty(this, '_config', void 0);\n\n    _defineProperty(this, '_transformCache', void 0);\n\n    _defineProperty(this, '_transformConfigCache', void 0);\n\n    this._config = config;\n    this._transformCache = new Map();\n    this._transformConfigCache = new Map();\n    const configString = (0, _fastJsonStableStringify().default)(this._config);\n    let projectCache = projectCaches.get(configString);\n\n    if (!projectCache) {\n      projectCache = {\n        configString,\n        ignorePatternsRegExp: calcIgnorePatternRegExp(this._config),\n        transformRegExp: calcTransformRegExp(this._config),\n        transformedFiles: new Map()\n      };\n      projectCaches.set(configString, projectCache);\n    }\n\n    this._cache = projectCache;\n  }\n\n  _getCacheKey(\n    fileData,\n    filename,\n    instrument,\n    supportsDynamicImport,\n    supportsStaticESM\n  ) {\n    const configString = this._cache.configString;\n\n    const transformer = this._getTransformer(filename);\n\n    if (transformer && typeof transformer.getCacheKey === 'function') {\n      return (0, _crypto().createHash)('md5')\n        .update(\n          transformer.getCacheKey(fileData, filename, configString, {\n            config: this._config,\n            instrument,\n            rootDir: this._config.rootDir,\n            supportsDynamicImport,\n            supportsStaticESM\n          })\n        )\n        .update(CACHE_VERSION)\n        .digest('hex');\n    } else {\n      return (0, _crypto().createHash)('md5')\n        .update(fileData)\n        .update(configString)\n        .update(instrument ? 'instrument' : '')\n        .update(filename)\n        .update(CACHE_VERSION)\n        .digest('hex');\n    }\n  }\n\n  _getFileCachePath(\n    filename,\n    content,\n    instrument,\n    supportsDynamicImport,\n    supportsStaticESM\n  ) {\n    const baseCacheDir = _jestHasteMap().default.getCacheFilePath(\n      this._config.cacheDirectory,\n      'jest-transform-cache-' + this._config.name,\n      VERSION\n    );\n\n    const cacheKey = this._getCacheKey(\n      content,\n      filename,\n      instrument,\n      supportsDynamicImport,\n      supportsStaticESM\n    ); // Create sub folders based on the cacheKey to avoid creating one\n    // directory with many files.\n\n    const cacheDir = path().join(baseCacheDir, cacheKey[0] + cacheKey[1]);\n    const cacheFilenamePrefix = path()\n      .basename(filename, path().extname(filename))\n      .replace(/\\W/g, '');\n    const cachePath = (0, _slash().default)(\n      path().join(cacheDir, cacheFilenamePrefix + '_' + cacheKey)\n    );\n    (0, _jestUtil().createDirectory)(cacheDir);\n    return cachePath;\n  }\n\n  _getTransformPath(filename) {\n    const transformRegExp = this._cache.transformRegExp;\n\n    if (!transformRegExp) {\n      return undefined;\n    }\n\n    for (let i = 0; i < transformRegExp.length; i++) {\n      if (transformRegExp[i][0].test(filename)) {\n        const transformPath = transformRegExp[i][1];\n\n        this._transformConfigCache.set(transformPath, transformRegExp[i][2]);\n\n        return transformPath;\n      }\n    }\n\n    return undefined;\n  }\n\n  _getTransformer(filename) {\n    if (!this._config.transform || !this._config.transform.length) {\n      return null;\n    }\n\n    const transformPath = this._getTransformPath(filename);\n\n    if (!transformPath) {\n      return null;\n    }\n\n    const transformer = this._transformCache.get(transformPath);\n\n    if (transformer) {\n      return transformer;\n    }\n\n    let transform = require(transformPath);\n\n    if (!transform) {\n      throw new TypeError('Jest: a transform must export something.');\n    }\n\n    const transformerConfig = this._transformConfigCache.get(transformPath);\n\n    if (typeof transform.createTransformer === 'function') {\n      transform = transform.createTransformer(transformerConfig);\n    }\n\n    if (typeof transform.process !== 'function') {\n      throw new TypeError(\n        'Jest: a transform must export a `process` function.'\n      );\n    }\n\n    this._transformCache.set(transformPath, transform);\n\n    return transform;\n  }\n\n  _instrumentFile(\n    filename,\n    input,\n    supportsDynamicImport,\n    supportsStaticESM,\n    canMapToInput\n  ) {\n    const inputCode = typeof input === 'string' ? input : input.code;\n    const inputMap = typeof input === 'string' ? null : input.map;\n    const result = (0, _core().transformSync)(inputCode, {\n      auxiliaryCommentBefore: ' istanbul ignore next ',\n      babelrc: false,\n      caller: {\n        name: '@jest/transform',\n        supportsDynamicImport,\n        supportsStaticESM\n      },\n      configFile: false,\n      filename,\n      plugins: [\n        [\n          _babelPluginIstanbul().default,\n          {\n            compact: false,\n            // files outside `cwd` will not be instrumented\n            cwd: this._config.rootDir,\n            exclude: [],\n            extension: false,\n            inputSourceMap: inputMap,\n            useInlineSourceMaps: false\n          }\n        ]\n      ],\n      sourceMaps: canMapToInput ? 'both' : false\n    });\n\n    if (result && result.code) {\n      return result;\n    }\n\n    return input;\n  } // We don't want to expose transformers to the outside - this function is just\n  // to warm up `this._transformCache`\n\n  preloadTransformer(filepath) {\n    this._getTransformer(filepath);\n  } // TODO: replace third argument with TransformOptions in Jest 26\n\n  transformSource(\n    filepath,\n    content,\n    instrument,\n    supportsDynamicImport = false,\n    supportsStaticESM = false\n  ) {\n    const filename = (0, _jestUtil().tryRealpath)(filepath);\n\n    const transform = this._getTransformer(filename);\n\n    const cacheFilePath = this._getFileCachePath(\n      filename,\n      content,\n      instrument,\n      supportsDynamicImport,\n      supportsStaticESM\n    );\n\n    let sourceMapPath = cacheFilePath + '.map'; // Ignore cache if `config.cache` is set (--no-cache)\n\n    let code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;\n    const shouldCallTransform = transform && this.shouldTransform(filename); // That means that the transform has a custom instrumentation\n    // logic and will handle it based on `config.collectCoverage` option\n\n    const transformWillInstrument =\n      shouldCallTransform && transform && transform.canInstrument;\n\n    if (code) {\n      // This is broken: we return the code, and a path for the source map\n      // directly from the cache. But, nothing ensures the source map actually\n      // matches that source code. They could have gotten out-of-sync in case\n      // two separate processes write concurrently to the same cache files.\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    }\n\n    let transformed = {\n      code: content,\n      map: null\n    };\n\n    if (transform && shouldCallTransform) {\n      const processed = transform.process(content, filename, this._config, {\n        instrument,\n        supportsDynamicImport,\n        supportsStaticESM\n      });\n\n      if (typeof processed === 'string') {\n        transformed.code = processed;\n      } else if (processed != null && typeof processed.code === 'string') {\n        transformed = processed;\n      } else {\n        throw new TypeError(\n          \"Jest: a transform's `process` function must return a string, \" +\n            'or an object with `code` key containing this string.'\n        );\n      }\n    }\n\n    if (!transformed.map) {\n      try {\n        //Could be a potential freeze here.\n        //See: https://github.com/facebook/jest/pull/5177#discussion_r158883570\n        const inlineSourceMap = (0, _convertSourceMap().fromSource)(\n          transformed.code\n        );\n\n        if (inlineSourceMap) {\n          transformed.map = inlineSourceMap.toObject();\n        }\n      } catch {\n        const transformPath = this._getTransformPath(filename);\n\n        console.warn(\n          `jest-transform: The source map produced for the file ${filename} ` +\n            `by ${transformPath} was invalid. Proceeding without source ` +\n            'mapping for that file.'\n        );\n      }\n    } // Apply instrumentation to the code if necessary, keeping the instrumented code and new map\n\n    let map = transformed.map;\n\n    if (!transformWillInstrument && instrument) {\n      /**\n       * We can map the original source code to the instrumented code ONLY if\n       * - the process of transforming the code produced a source map e.g. ts-jest\n       * - we did not transform the source code\n       *\n       * Otherwise we cannot make any statements about how the instrumented code corresponds to the original code,\n       * and we should NOT emit any source maps\n       *\n       */\n      const shouldEmitSourceMaps =\n        (transform != null && map != null) || transform == null;\n\n      const instrumented = this._instrumentFile(\n        filename,\n        transformed,\n        supportsDynamicImport,\n        supportsStaticESM,\n        shouldEmitSourceMaps\n      );\n\n      code =\n        typeof instrumented === 'string' ? instrumented : instrumented.code;\n      map = typeof instrumented === 'string' ? null : instrumented.map;\n    } else {\n      code = transformed.code;\n    }\n\n    if (map) {\n      const sourceMapContent =\n        typeof map === 'string' ? map : JSON.stringify(map);\n      writeCacheFile(sourceMapPath, sourceMapContent);\n    } else {\n      sourceMapPath = null;\n    }\n\n    writeCodeCacheFile(cacheFilePath, code);\n    return {\n      code,\n      originalCode: content,\n      sourceMapPath\n    };\n  }\n\n  _transformAndBuildScript(filename, options, instrument, fileSource) {\n    const {\n      isCoreModule,\n      isInternalModule,\n      supportsDynamicImport,\n      supportsStaticESM\n    } = options;\n    const content = stripShebang(\n      fileSource || fs().readFileSync(filename, 'utf8')\n    );\n    let code = content;\n    let sourceMapPath = null;\n    const willTransform =\n      !isInternalModule &&\n      !isCoreModule &&\n      (this.shouldTransform(filename) || instrument);\n\n    try {\n      if (willTransform) {\n        const transformedSource = this.transformSource(\n          filename,\n          content,\n          instrument,\n          supportsDynamicImport,\n          supportsStaticESM\n        );\n        code = transformedSource.code;\n        sourceMapPath = transformedSource.sourceMapPath;\n      }\n\n      return {\n        code,\n        originalCode: content,\n        sourceMapPath\n      };\n    } catch (e) {\n      throw (0, _enhanceUnexpectedTokenMessage.default)(e);\n    }\n  }\n\n  transform(filename, options, fileSource) {\n    let scriptCacheKey = undefined;\n    let instrument = false;\n\n    if (!options.isCoreModule) {\n      instrument =\n        options.coverageProvider === 'babel' &&\n        (0, _shouldInstrument.default)(filename, options, this._config);\n      scriptCacheKey = getScriptCacheKey(filename, instrument);\n\n      const result = this._cache.transformedFiles.get(scriptCacheKey);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    const result = this._transformAndBuildScript(\n      filename,\n      options,\n      instrument,\n      fileSource\n    );\n\n    if (scriptCacheKey) {\n      this._cache.transformedFiles.set(scriptCacheKey, result);\n    }\n\n    return result;\n  }\n\n  transformJson(filename, options, fileSource) {\n    const {\n      isCoreModule,\n      isInternalModule,\n      supportsDynamicImport,\n      supportsStaticESM\n    } = options;\n    const willTransform =\n      !isInternalModule && !isCoreModule && this.shouldTransform(filename);\n\n    if (willTransform) {\n      const {code: transformedJsonSource} = this.transformSource(\n        filename,\n        fileSource,\n        false,\n        supportsDynamicImport,\n        supportsStaticESM\n      );\n      return transformedJsonSource;\n    }\n\n    return fileSource;\n  }\n\n  requireAndTranspileModule(moduleName, callback) {\n    // Load the transformer to avoid a cycle where we need to load a\n    // transformer in order to transform it in the require hooks\n    this.preloadTransformer(moduleName);\n    let transforming = false;\n    const revertHook = (0, _pirates().addHook)(\n      (code, filename) => {\n        try {\n          transforming = true;\n          return (\n            // we might wanna do `supportsDynamicImport` at some point\n            this.transformSource(filename, code, false, false, false).code ||\n            code\n          );\n        } finally {\n          transforming = false;\n        }\n      },\n      {\n        exts: this._config.moduleFileExtensions.map(ext => `.${ext}`),\n        ignoreNodeModules: false,\n        matcher: filename => {\n          if (transforming) {\n            // Don't transform any dependency required by the transformer itself\n            return false;\n          }\n\n          return this.shouldTransform(filename);\n        }\n      }\n    );\n\n    const module = require(moduleName);\n\n    if (!callback) {\n      revertHook();\n      return module;\n    }\n\n    try {\n      const cbResult = callback(module);\n\n      if ((0, _jestUtil().isPromise)(cbResult)) {\n        return waitForPromiseWithCleanup(cbResult, revertHook).then(\n          () => module\n        );\n      }\n    } finally {\n      revertHook();\n    }\n\n    return module;\n  }\n  /**\n   * @deprecated use `this.shouldTransform` instead\n   */\n  // @ts-expect-error: Unused and private - remove in Jest 25\n\n  _shouldTransform(filename) {\n    return this.shouldTransform(filename);\n  }\n\n  shouldTransform(filename) {\n    const ignoreRegexp = this._cache.ignorePatternsRegExp;\n    const isIgnored = ignoreRegexp ? ignoreRegexp.test(filename) : false;\n    return (\n      !!this._config.transform && !!this._config.transform.length && !isIgnored\n    );\n  }\n} // TODO: do we need to define the generics twice?\n\nexports.default = ScriptTransformer;\n\nfunction createTranspilingRequire(config) {\n  const transformer = new ScriptTransformer(config);\n  return function requireAndTranspileModule(\n    resolverPath,\n    applyInteropRequireDefault = false\n  ) {\n    const transpiledModule = transformer.requireAndTranspileModule(\n      resolverPath\n    );\n    return applyInteropRequireDefault\n      ? (0, _jestUtil().interopRequireDefault)(transpiledModule).default\n      : transpiledModule;\n  };\n}\n\nconst removeFile = path => {\n  try {\n    fs().unlinkSync(path);\n  } catch {}\n};\n\nconst stripShebang = content => {\n  // If the file data starts with a shebang remove it. Leaves the empty line\n  // to keep stack trace line numbers correct.\n  if (content.startsWith('#!')) {\n    return content.replace(/^#!.*/, '');\n  } else {\n    return content;\n  }\n};\n/**\n * This is like `writeCacheFile` but with an additional sanity checksum. We\n * cannot use the same technique for source maps because we expose source map\n * cache file paths directly to callsites, with the expectation they can read\n * it right away. This is not a great system, because source map cache file\n * could get corrupted, out-of-sync, etc.\n */\n\nfunction writeCodeCacheFile(cachePath, code) {\n  const checksum = (0, _crypto().createHash)('md5').update(code).digest('hex');\n  writeCacheFile(cachePath, checksum + '\\n' + code);\n}\n/**\n * Read counterpart of `writeCodeCacheFile`. We verify that the content of the\n * file matches the checksum, in case some kind of corruption happened. This\n * could happen if an older version of `jest-runtime` writes non-atomically to\n * the same cache, for example.\n */\n\nfunction readCodeCacheFile(cachePath) {\n  const content = readCacheFile(cachePath);\n\n  if (content == null) {\n    return null;\n  }\n\n  const code = content.substr(33);\n  const checksum = (0, _crypto().createHash)('md5').update(code).digest('hex');\n\n  if (checksum === content.substr(0, 32)) {\n    return code;\n  }\n\n  return null;\n}\n/**\n * Writing to the cache atomically relies on 'rename' being atomic on most\n * file systems. Doing atomic write reduces the risk of corruption by avoiding\n * two processes to write to the same file at the same time. It also reduces\n * the risk of reading a file that's being overwritten at the same time.\n */\n\nconst writeCacheFile = (cachePath, fileData) => {\n  try {\n    (0, _writeFileAtomic().sync)(cachePath, fileData, {\n      encoding: 'utf8',\n      fsync: false\n    });\n  } catch (e) {\n    if (cacheWriteErrorSafeToIgnore(e, cachePath)) {\n      return;\n    }\n\n    e.message =\n      'jest: failed to cache transform results in: ' +\n      cachePath +\n      '\\nFailure message: ' +\n      e.message;\n    removeFile(cachePath);\n    throw e;\n  }\n};\n/**\n * On Windows, renames are not atomic, leading to EPERM exceptions when two\n * processes attempt to rename to the same target file at the same time.\n * If the target file exists we can be reasonably sure another process has\n * legitimately won a cache write race and ignore the error.\n */\n\nconst cacheWriteErrorSafeToIgnore = (e, cachePath) =>\n  process.platform === 'win32' &&\n  e.code === 'EPERM' &&\n  fs().existsSync(cachePath);\n\nconst readCacheFile = cachePath => {\n  if (!fs().existsSync(cachePath)) {\n    return null;\n  }\n\n  let fileData;\n\n  try {\n    fileData = fs().readFileSync(cachePath, 'utf8');\n  } catch (e) {\n    e.message =\n      'jest: failed to read cache file: ' +\n      cachePath +\n      '\\nFailure message: ' +\n      e.message;\n    removeFile(cachePath);\n    throw e;\n  }\n\n  if (fileData == null) {\n    // We must have somehow created the file but failed to write to it,\n    // let's delete it and retry.\n    removeFile(cachePath);\n  }\n\n  return fileData;\n};\n\nconst getScriptCacheKey = (filename, instrument) => {\n  const mtime = fs().statSync(filename).mtime;\n  return filename + '_' + mtime.getTime() + (instrument ? '_instrumented' : '');\n};\n\nconst calcIgnorePatternRegExp = config => {\n  if (\n    !config.transformIgnorePatterns ||\n    config.transformIgnorePatterns.length === 0\n  ) {\n    return undefined;\n  }\n\n  return new RegExp(config.transformIgnorePatterns.join('|'));\n};\n\nconst calcTransformRegExp = config => {\n  if (!config.transform.length) {\n    return undefined;\n  }\n\n  const transformRegexp = [];\n\n  for (let i = 0; i < config.transform.length; i++) {\n    transformRegexp.push([\n      new RegExp(config.transform[i][0]),\n      config.transform[i][1],\n      config.transform[i][2]\n    ]);\n  }\n\n  return transformRegexp;\n};\n"]},"metadata":{},"sourceType":"script"}