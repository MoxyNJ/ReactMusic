{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _util() {\n  const data = _interopRequireDefault(require('util'));\n\n  _util = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst MS_IN_A_YEAR = 31536000000;\n\nclass FakeTimers {\n  constructor({\n    global,\n    moduleMocker,\n    timerConfig,\n    config,\n    maxLoops\n  }) {\n    _defineProperty(this, '_cancelledTicks', void 0);\n\n    _defineProperty(this, '_config', void 0);\n\n    _defineProperty(this, '_disposed', void 0);\n\n    _defineProperty(this, '_fakeTimerAPIs', void 0);\n\n    _defineProperty(this, '_global', void 0);\n\n    _defineProperty(this, '_immediates', void 0);\n\n    _defineProperty(this, '_maxLoops', void 0);\n\n    _defineProperty(this, '_moduleMocker', void 0);\n\n    _defineProperty(this, '_now', void 0);\n\n    _defineProperty(this, '_ticks', void 0);\n\n    _defineProperty(this, '_timerAPIs', void 0);\n\n    _defineProperty(this, '_timers', void 0);\n\n    _defineProperty(this, '_uuidCounter', void 0);\n\n    _defineProperty(this, '_timerConfig', void 0);\n\n    this._global = global;\n    this._timerConfig = timerConfig;\n    this._config = config;\n    this._maxLoops = maxLoops || 100000;\n    this._uuidCounter = 1;\n    this._moduleMocker = moduleMocker; // Store original timer APIs for future reference\n\n    this._timerAPIs = {\n      clearImmediate: global.clearImmediate,\n      clearInterval: global.clearInterval,\n      clearTimeout: global.clearTimeout,\n      nextTick: global.process && global.process.nextTick,\n      setImmediate: global.setImmediate,\n      setInterval: global.setInterval,\n      setTimeout: global.setTimeout\n    };\n    this.reset();\n  }\n\n  clearAllTimers() {\n    this._immediates = [];\n\n    this._timers.clear();\n  }\n\n  dispose() {\n    this._disposed = true;\n    this.clearAllTimers();\n  }\n\n  reset() {\n    this._cancelledTicks = {};\n    this._now = 0;\n    this._ticks = [];\n    this._immediates = [];\n    this._timers = new Map();\n  }\n\n  runAllTicks() {\n    this._checkFakeTimers(); // Only run a generous number of ticks and then bail.\n    // This is just to help avoid recursive loops\n\n\n    let i;\n\n    for (i = 0; i < this._maxLoops; i++) {\n      const tick = this._ticks.shift();\n\n      if (tick === undefined) {\n        break;\n      }\n\n      if (!this._cancelledTicks.hasOwnProperty(tick.uuid)) {\n        // Callback may throw, so update the map prior calling.\n        this._cancelledTicks[tick.uuid] = true;\n        tick.callback();\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error('Ran ' + this._maxLoops + ' ticks, and there are still more! ' + \"Assuming we've hit an infinite recursion and bailing out...\");\n    }\n  }\n\n  runAllImmediates() {\n    this._checkFakeTimers(); // Only run a generous number of immediates and then bail.\n\n\n    let i;\n\n    for (i = 0; i < this._maxLoops; i++) {\n      const immediate = this._immediates.shift();\n\n      if (immediate === undefined) {\n        break;\n      }\n\n      this._runImmediate(immediate);\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error('Ran ' + this._maxLoops + ' immediates, and there are still more! Assuming ' + \"we've hit an infinite recursion and bailing out...\");\n    }\n  }\n\n  _runImmediate(immediate) {\n    try {\n      immediate.callback();\n    } finally {\n      this._fakeClearImmediate(immediate.uuid);\n    }\n  }\n\n  runAllTimers() {\n    this._checkFakeTimers();\n\n    this.runAllTicks();\n    this.runAllImmediates(); // Only run a generous number of timers and then bail.\n    // This is just to help avoid recursive loops\n\n    let i;\n\n    for (i = 0; i < this._maxLoops; i++) {\n      const nextTimerHandle = this._getNextTimerHandle(); // If there are no more timer handles, stop!\n\n\n      if (nextTimerHandle === null) {\n        break;\n      }\n\n      this._runTimerHandle(nextTimerHandle); // Some of the immediate calls could be enqueued\n      // during the previous handling of the timers, we should\n      // run them as well.\n\n\n      if (this._immediates.length) {\n        this.runAllImmediates();\n      }\n\n      if (this._ticks.length) {\n        this.runAllTicks();\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error('Ran ' + this._maxLoops + ' timers, and there are still more! ' + \"Assuming we've hit an infinite recursion and bailing out...\");\n    }\n  }\n\n  runOnlyPendingTimers() {\n    // We need to hold the current shape of `this._timers` because existing\n    // timers can add new ones to the map and hence would run more than necessary.\n    // See https://github.com/facebook/jest/pull/4608 for details\n    const timerEntries = Array.from(this._timers.entries());\n\n    this._checkFakeTimers();\n\n    this._immediates.forEach(this._runImmediate, this);\n\n    timerEntries.sort(([, left], [, right]) => left.expiry - right.expiry).forEach(([timerHandle]) => this._runTimerHandle(timerHandle));\n  }\n\n  advanceTimersToNextTimer(steps = 1) {\n    if (steps < 1) {\n      return;\n    }\n\n    const nextExpiry = Array.from(this._timers.values()).reduce((minExpiry, timer) => {\n      if (minExpiry === null || timer.expiry < minExpiry) return timer.expiry;\n      return minExpiry;\n    }, null);\n\n    if (nextExpiry !== null) {\n      this.advanceTimersByTime(nextExpiry - this._now);\n      this.advanceTimersToNextTimer(steps - 1);\n    }\n  }\n\n  advanceTimersByTime(msToRun) {\n    this._checkFakeTimers(); // Only run a generous number of timers and then bail.\n    // This is just to help avoid recursive loops\n\n\n    let i;\n\n    for (i = 0; i < this._maxLoops; i++) {\n      const timerHandle = this._getNextTimerHandle(); // If there are no more timer handles, stop!\n\n\n      if (timerHandle === null) {\n        break;\n      }\n\n      const timerValue = this._timers.get(timerHandle);\n\n      if (timerValue === undefined) {\n        break;\n      }\n\n      const nextTimerExpiry = timerValue.expiry;\n\n      if (this._now + msToRun < nextTimerExpiry) {\n        // There are no timers between now and the target we're running to, so\n        // adjust our time cursor and quit\n        this._now += msToRun;\n        break;\n      } else {\n        msToRun -= nextTimerExpiry - this._now;\n        this._now = nextTimerExpiry;\n\n        this._runTimerHandle(timerHandle);\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error('Ran ' + this._maxLoops + ' timers, and there are still more! ' + \"Assuming we've hit an infinite recursion and bailing out...\");\n    }\n  }\n\n  runWithRealTimers(cb) {\n    const prevClearImmediate = this._global.clearImmediate;\n    const prevClearInterval = this._global.clearInterval;\n    const prevClearTimeout = this._global.clearTimeout;\n    const prevNextTick = this._global.process.nextTick;\n    const prevSetImmediate = this._global.setImmediate;\n    const prevSetInterval = this._global.setInterval;\n    const prevSetTimeout = this._global.setTimeout;\n    this.useRealTimers();\n    let cbErr = null;\n    let errThrown = false;\n\n    try {\n      cb();\n    } catch (e) {\n      errThrown = true;\n      cbErr = e;\n    }\n\n    this._global.clearImmediate = prevClearImmediate;\n    this._global.clearInterval = prevClearInterval;\n    this._global.clearTimeout = prevClearTimeout;\n    this._global.process.nextTick = prevNextTick;\n    this._global.setImmediate = prevSetImmediate;\n    this._global.setInterval = prevSetInterval;\n    this._global.setTimeout = prevSetTimeout;\n\n    if (errThrown) {\n      throw cbErr;\n    }\n  }\n\n  useRealTimers() {\n    const global = this._global;\n    (0, _jestUtil().setGlobal)(global, 'clearImmediate', this._timerAPIs.clearImmediate);\n    (0, _jestUtil().setGlobal)(global, 'clearInterval', this._timerAPIs.clearInterval);\n    (0, _jestUtil().setGlobal)(global, 'clearTimeout', this._timerAPIs.clearTimeout);\n    (0, _jestUtil().setGlobal)(global, 'setImmediate', this._timerAPIs.setImmediate);\n    (0, _jestUtil().setGlobal)(global, 'setInterval', this._timerAPIs.setInterval);\n    (0, _jestUtil().setGlobal)(global, 'setTimeout', this._timerAPIs.setTimeout);\n    global.process.nextTick = this._timerAPIs.nextTick;\n  }\n\n  useFakeTimers() {\n    this._createMocks();\n\n    const global = this._global;\n    (0, _jestUtil().setGlobal)(global, 'clearImmediate', this._fakeTimerAPIs.clearImmediate);\n    (0, _jestUtil().setGlobal)(global, 'clearInterval', this._fakeTimerAPIs.clearInterval);\n    (0, _jestUtil().setGlobal)(global, 'clearTimeout', this._fakeTimerAPIs.clearTimeout);\n    (0, _jestUtil().setGlobal)(global, 'setImmediate', this._fakeTimerAPIs.setImmediate);\n    (0, _jestUtil().setGlobal)(global, 'setInterval', this._fakeTimerAPIs.setInterval);\n    (0, _jestUtil().setGlobal)(global, 'setTimeout', this._fakeTimerAPIs.setTimeout);\n    global.process.nextTick = this._fakeTimerAPIs.nextTick;\n  }\n\n  getTimerCount() {\n    this._checkFakeTimers();\n\n    return this._timers.size + this._immediates.length + this._ticks.length;\n  }\n\n  _checkFakeTimers() {\n    var _this$_fakeTimerAPIs;\n\n    if (this._global.setTimeout !== ((_this$_fakeTimerAPIs = this._fakeTimerAPIs) === null || _this$_fakeTimerAPIs === void 0 ? void 0 : _this$_fakeTimerAPIs.setTimeout)) {\n      this._global.console.warn(`A function to advance timers was called but the timers API is not ` + `mocked with fake timers. Call \\`jest.useFakeTimers()\\` in this ` + `test or enable fake timers globally by setting ` + `\\`\"timers\": \"fake\"\\` in ` + `the configuration file. This warning is likely a result of a ` + `default configuration change in Jest 15.\\n\\n` + `Release Blog Post: https://jestjs.io/blog/2016/09/01/jest-15.html\\n` + `Stack Trace:\\n` + (0, _jestMessageUtil().formatStackTrace)(new Error().stack, this._config, {\n        noStackTrace: false\n      }));\n    }\n  }\n\n  _createMocks() {\n    const fn = (impl // @ts-expect-error TODO: figure out better typings here\n    ) => this._moduleMocker.fn().mockImplementation(impl);\n\n    const promisifiableFakeSetTimeout = fn(this._fakeSetTimeout.bind(this)); // @ts-expect-error TODO: figure out better typings here\n\n    promisifiableFakeSetTimeout[_util().default.promisify.custom] = (delay, arg) => new Promise(resolve => promisifiableFakeSetTimeout(resolve, delay, arg)); // TODO: add better typings; these are mocks, but typed as regular timers\n\n\n    this._fakeTimerAPIs = {\n      clearImmediate: fn(this._fakeClearImmediate.bind(this)),\n      clearInterval: fn(this._fakeClearTimer.bind(this)),\n      clearTimeout: fn(this._fakeClearTimer.bind(this)),\n      nextTick: fn(this._fakeNextTick.bind(this)),\n      // @ts-expect-error TODO: figure out better typings here\n      setImmediate: fn(this._fakeSetImmediate.bind(this)),\n      // @ts-expect-error TODO: figure out better typings here\n      setInterval: fn(this._fakeSetInterval.bind(this)),\n      // @ts-expect-error TODO: figure out better typings here\n      setTimeout: promisifiableFakeSetTimeout\n    };\n  }\n\n  _fakeClearTimer(timerRef) {\n    const uuid = this._timerConfig.refToId(timerRef);\n\n    if (uuid) {\n      this._timers.delete(String(uuid));\n    }\n  }\n\n  _fakeClearImmediate(uuid) {\n    this._immediates = this._immediates.filter(immediate => immediate.uuid !== uuid);\n  }\n\n  _fakeNextTick(callback, ...args) {\n    if (this._disposed) {\n      return;\n    }\n\n    const uuid = String(this._uuidCounter++);\n\n    this._ticks.push({\n      callback: () => callback.apply(null, args),\n      uuid\n    });\n\n    const cancelledTicks = this._cancelledTicks;\n\n    this._timerAPIs.nextTick(() => {\n      if (!cancelledTicks.hasOwnProperty(uuid)) {\n        // Callback may throw, so update the map prior calling.\n        cancelledTicks[uuid] = true;\n        callback.apply(null, args);\n      }\n    });\n  }\n\n  _fakeSetImmediate(callback, ...args) {\n    if (this._disposed) {\n      return null;\n    }\n\n    const uuid = String(this._uuidCounter++);\n\n    this._immediates.push({\n      callback: () => callback.apply(null, args),\n      uuid\n    });\n\n    this._timerAPIs.setImmediate(() => {\n      if (this._immediates.find(x => x.uuid === uuid)) {\n        try {\n          callback.apply(null, args);\n        } finally {\n          this._fakeClearImmediate(uuid);\n        }\n      }\n    });\n\n    return uuid;\n  }\n\n  _fakeSetInterval(callback, intervalDelay, ...args) {\n    if (this._disposed) {\n      return null;\n    }\n\n    if (intervalDelay == null) {\n      intervalDelay = 0;\n    }\n\n    const uuid = this._uuidCounter++;\n\n    this._timers.set(String(uuid), {\n      callback: () => callback.apply(null, args),\n      expiry: this._now + intervalDelay,\n      interval: intervalDelay,\n      type: 'interval'\n    });\n\n    return this._timerConfig.idToRef(uuid);\n  }\n\n  _fakeSetTimeout(callback, delay, ...args) {\n    if (this._disposed) {\n      return null;\n    } // eslint-disable-next-line no-bitwise\n\n\n    delay = Number(delay) | 0;\n    const uuid = this._uuidCounter++;\n\n    this._timers.set(String(uuid), {\n      callback: () => callback.apply(null, args),\n      expiry: this._now + delay,\n      interval: undefined,\n      type: 'timeout'\n    });\n\n    return this._timerConfig.idToRef(uuid);\n  }\n\n  _getNextTimerHandle() {\n    let nextTimerHandle = null;\n    let soonestTime = MS_IN_A_YEAR;\n\n    this._timers.forEach((timer, uuid) => {\n      if (timer.expiry < soonestTime) {\n        soonestTime = timer.expiry;\n        nextTimerHandle = uuid;\n      }\n    });\n\n    return nextTimerHandle;\n  }\n\n  _runTimerHandle(timerHandle) {\n    const timer = this._timers.get(timerHandle);\n\n    if (!timer) {\n      return;\n    }\n\n    switch (timer.type) {\n      case 'timeout':\n        const callback = timer.callback;\n\n        this._timers.delete(timerHandle);\n\n        callback();\n        break;\n\n      case 'interval':\n        timer.expiry = this._now + (timer.interval || 0);\n        timer.callback();\n        break;\n\n      default:\n        throw new Error('Unexpected timer type: ' + timer.type);\n    }\n  }\n\n}\n\nexports.default = FakeTimers;","map":{"version":3,"sources":["F:/GreenTea-Lemon/React/coderwhyReact/我的代码/15_learn_hooks/node_modules/@jest/fake-timers/build/legacyFakeTimers.js"],"names":["Object","defineProperty","exports","value","default","_util","data","_interopRequireDefault","require","_jestMessageUtil","_jestUtil","obj","__esModule","_defineProperty","key","enumerable","configurable","writable","MS_IN_A_YEAR","FakeTimers","constructor","global","moduleMocker","timerConfig","config","maxLoops","_global","_timerConfig","_config","_maxLoops","_uuidCounter","_moduleMocker","_timerAPIs","clearImmediate","clearInterval","clearTimeout","nextTick","process","setImmediate","setInterval","setTimeout","reset","clearAllTimers","_immediates","_timers","clear","dispose","_disposed","_cancelledTicks","_now","_ticks","Map","runAllTicks","_checkFakeTimers","i","tick","shift","undefined","hasOwnProperty","uuid","callback","Error","runAllImmediates","immediate","_runImmediate","_fakeClearImmediate","runAllTimers","nextTimerHandle","_getNextTimerHandle","_runTimerHandle","length","runOnlyPendingTimers","timerEntries","Array","from","entries","forEach","sort","left","right","expiry","timerHandle","advanceTimersToNextTimer","steps","nextExpiry","values","reduce","minExpiry","timer","advanceTimersByTime","msToRun","timerValue","get","nextTimerExpiry","runWithRealTimers","cb","prevClearImmediate","prevClearInterval","prevClearTimeout","prevNextTick","prevSetImmediate","prevSetInterval","prevSetTimeout","useRealTimers","cbErr","errThrown","e","setGlobal","useFakeTimers","_createMocks","_fakeTimerAPIs","getTimerCount","size","_this$_fakeTimerAPIs","console","warn","formatStackTrace","stack","noStackTrace","fn","impl","mockImplementation","promisifiableFakeSetTimeout","_fakeSetTimeout","bind","promisify","custom","delay","arg","Promise","resolve","_fakeClearTimer","_fakeNextTick","_fakeSetImmediate","_fakeSetInterval","timerRef","refToId","delete","String","filter","args","push","apply","cancelledTicks","find","x","intervalDelay","set","interval","type","idToRef","Number","soonestTime"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nfunction _util() {\n  const data = _interopRequireDefault(require('util'));\n\n  _util = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nconst MS_IN_A_YEAR = 31536000000;\n\nclass FakeTimers {\n  constructor({global, moduleMocker, timerConfig, config, maxLoops}) {\n    _defineProperty(this, '_cancelledTicks', void 0);\n\n    _defineProperty(this, '_config', void 0);\n\n    _defineProperty(this, '_disposed', void 0);\n\n    _defineProperty(this, '_fakeTimerAPIs', void 0);\n\n    _defineProperty(this, '_global', void 0);\n\n    _defineProperty(this, '_immediates', void 0);\n\n    _defineProperty(this, '_maxLoops', void 0);\n\n    _defineProperty(this, '_moduleMocker', void 0);\n\n    _defineProperty(this, '_now', void 0);\n\n    _defineProperty(this, '_ticks', void 0);\n\n    _defineProperty(this, '_timerAPIs', void 0);\n\n    _defineProperty(this, '_timers', void 0);\n\n    _defineProperty(this, '_uuidCounter', void 0);\n\n    _defineProperty(this, '_timerConfig', void 0);\n\n    this._global = global;\n    this._timerConfig = timerConfig;\n    this._config = config;\n    this._maxLoops = maxLoops || 100000;\n    this._uuidCounter = 1;\n    this._moduleMocker = moduleMocker; // Store original timer APIs for future reference\n\n    this._timerAPIs = {\n      clearImmediate: global.clearImmediate,\n      clearInterval: global.clearInterval,\n      clearTimeout: global.clearTimeout,\n      nextTick: global.process && global.process.nextTick,\n      setImmediate: global.setImmediate,\n      setInterval: global.setInterval,\n      setTimeout: global.setTimeout\n    };\n    this.reset();\n  }\n\n  clearAllTimers() {\n    this._immediates = [];\n\n    this._timers.clear();\n  }\n\n  dispose() {\n    this._disposed = true;\n    this.clearAllTimers();\n  }\n\n  reset() {\n    this._cancelledTicks = {};\n    this._now = 0;\n    this._ticks = [];\n    this._immediates = [];\n    this._timers = new Map();\n  }\n\n  runAllTicks() {\n    this._checkFakeTimers(); // Only run a generous number of ticks and then bail.\n    // This is just to help avoid recursive loops\n\n    let i;\n\n    for (i = 0; i < this._maxLoops; i++) {\n      const tick = this._ticks.shift();\n\n      if (tick === undefined) {\n        break;\n      }\n\n      if (!this._cancelledTicks.hasOwnProperty(tick.uuid)) {\n        // Callback may throw, so update the map prior calling.\n        this._cancelledTicks[tick.uuid] = true;\n        tick.callback();\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error(\n        'Ran ' +\n          this._maxLoops +\n          ' ticks, and there are still more! ' +\n          \"Assuming we've hit an infinite recursion and bailing out...\"\n      );\n    }\n  }\n\n  runAllImmediates() {\n    this._checkFakeTimers(); // Only run a generous number of immediates and then bail.\n\n    let i;\n\n    for (i = 0; i < this._maxLoops; i++) {\n      const immediate = this._immediates.shift();\n\n      if (immediate === undefined) {\n        break;\n      }\n\n      this._runImmediate(immediate);\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error(\n        'Ran ' +\n          this._maxLoops +\n          ' immediates, and there are still more! Assuming ' +\n          \"we've hit an infinite recursion and bailing out...\"\n      );\n    }\n  }\n\n  _runImmediate(immediate) {\n    try {\n      immediate.callback();\n    } finally {\n      this._fakeClearImmediate(immediate.uuid);\n    }\n  }\n\n  runAllTimers() {\n    this._checkFakeTimers();\n\n    this.runAllTicks();\n    this.runAllImmediates(); // Only run a generous number of timers and then bail.\n    // This is just to help avoid recursive loops\n\n    let i;\n\n    for (i = 0; i < this._maxLoops; i++) {\n      const nextTimerHandle = this._getNextTimerHandle(); // If there are no more timer handles, stop!\n\n      if (nextTimerHandle === null) {\n        break;\n      }\n\n      this._runTimerHandle(nextTimerHandle); // Some of the immediate calls could be enqueued\n      // during the previous handling of the timers, we should\n      // run them as well.\n\n      if (this._immediates.length) {\n        this.runAllImmediates();\n      }\n\n      if (this._ticks.length) {\n        this.runAllTicks();\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error(\n        'Ran ' +\n          this._maxLoops +\n          ' timers, and there are still more! ' +\n          \"Assuming we've hit an infinite recursion and bailing out...\"\n      );\n    }\n  }\n\n  runOnlyPendingTimers() {\n    // We need to hold the current shape of `this._timers` because existing\n    // timers can add new ones to the map and hence would run more than necessary.\n    // See https://github.com/facebook/jest/pull/4608 for details\n    const timerEntries = Array.from(this._timers.entries());\n\n    this._checkFakeTimers();\n\n    this._immediates.forEach(this._runImmediate, this);\n\n    timerEntries\n      .sort(([, left], [, right]) => left.expiry - right.expiry)\n      .forEach(([timerHandle]) => this._runTimerHandle(timerHandle));\n  }\n\n  advanceTimersToNextTimer(steps = 1) {\n    if (steps < 1) {\n      return;\n    }\n\n    const nextExpiry = Array.from(this._timers.values()).reduce(\n      (minExpiry, timer) => {\n        if (minExpiry === null || timer.expiry < minExpiry) return timer.expiry;\n        return minExpiry;\n      },\n      null\n    );\n\n    if (nextExpiry !== null) {\n      this.advanceTimersByTime(nextExpiry - this._now);\n      this.advanceTimersToNextTimer(steps - 1);\n    }\n  }\n\n  advanceTimersByTime(msToRun) {\n    this._checkFakeTimers(); // Only run a generous number of timers and then bail.\n    // This is just to help avoid recursive loops\n\n    let i;\n\n    for (i = 0; i < this._maxLoops; i++) {\n      const timerHandle = this._getNextTimerHandle(); // If there are no more timer handles, stop!\n\n      if (timerHandle === null) {\n        break;\n      }\n\n      const timerValue = this._timers.get(timerHandle);\n\n      if (timerValue === undefined) {\n        break;\n      }\n\n      const nextTimerExpiry = timerValue.expiry;\n\n      if (this._now + msToRun < nextTimerExpiry) {\n        // There are no timers between now and the target we're running to, so\n        // adjust our time cursor and quit\n        this._now += msToRun;\n        break;\n      } else {\n        msToRun -= nextTimerExpiry - this._now;\n        this._now = nextTimerExpiry;\n\n        this._runTimerHandle(timerHandle);\n      }\n    }\n\n    if (i === this._maxLoops) {\n      throw new Error(\n        'Ran ' +\n          this._maxLoops +\n          ' timers, and there are still more! ' +\n          \"Assuming we've hit an infinite recursion and bailing out...\"\n      );\n    }\n  }\n\n  runWithRealTimers(cb) {\n    const prevClearImmediate = this._global.clearImmediate;\n    const prevClearInterval = this._global.clearInterval;\n    const prevClearTimeout = this._global.clearTimeout;\n    const prevNextTick = this._global.process.nextTick;\n    const prevSetImmediate = this._global.setImmediate;\n    const prevSetInterval = this._global.setInterval;\n    const prevSetTimeout = this._global.setTimeout;\n    this.useRealTimers();\n    let cbErr = null;\n    let errThrown = false;\n\n    try {\n      cb();\n    } catch (e) {\n      errThrown = true;\n      cbErr = e;\n    }\n\n    this._global.clearImmediate = prevClearImmediate;\n    this._global.clearInterval = prevClearInterval;\n    this._global.clearTimeout = prevClearTimeout;\n    this._global.process.nextTick = prevNextTick;\n    this._global.setImmediate = prevSetImmediate;\n    this._global.setInterval = prevSetInterval;\n    this._global.setTimeout = prevSetTimeout;\n\n    if (errThrown) {\n      throw cbErr;\n    }\n  }\n\n  useRealTimers() {\n    const global = this._global;\n    (0, _jestUtil().setGlobal)(\n      global,\n      'clearImmediate',\n      this._timerAPIs.clearImmediate\n    );\n    (0, _jestUtil().setGlobal)(\n      global,\n      'clearInterval',\n      this._timerAPIs.clearInterval\n    );\n    (0, _jestUtil().setGlobal)(\n      global,\n      'clearTimeout',\n      this._timerAPIs.clearTimeout\n    );\n    (0, _jestUtil().setGlobal)(\n      global,\n      'setImmediate',\n      this._timerAPIs.setImmediate\n    );\n    (0, _jestUtil().setGlobal)(\n      global,\n      'setInterval',\n      this._timerAPIs.setInterval\n    );\n    (0, _jestUtil().setGlobal)(\n      global,\n      'setTimeout',\n      this._timerAPIs.setTimeout\n    );\n    global.process.nextTick = this._timerAPIs.nextTick;\n  }\n\n  useFakeTimers() {\n    this._createMocks();\n\n    const global = this._global;\n    (0, _jestUtil().setGlobal)(\n      global,\n      'clearImmediate',\n      this._fakeTimerAPIs.clearImmediate\n    );\n    (0, _jestUtil().setGlobal)(\n      global,\n      'clearInterval',\n      this._fakeTimerAPIs.clearInterval\n    );\n    (0, _jestUtil().setGlobal)(\n      global,\n      'clearTimeout',\n      this._fakeTimerAPIs.clearTimeout\n    );\n    (0, _jestUtil().setGlobal)(\n      global,\n      'setImmediate',\n      this._fakeTimerAPIs.setImmediate\n    );\n    (0, _jestUtil().setGlobal)(\n      global,\n      'setInterval',\n      this._fakeTimerAPIs.setInterval\n    );\n    (0, _jestUtil().setGlobal)(\n      global,\n      'setTimeout',\n      this._fakeTimerAPIs.setTimeout\n    );\n    global.process.nextTick = this._fakeTimerAPIs.nextTick;\n  }\n\n  getTimerCount() {\n    this._checkFakeTimers();\n\n    return this._timers.size + this._immediates.length + this._ticks.length;\n  }\n\n  _checkFakeTimers() {\n    var _this$_fakeTimerAPIs;\n\n    if (\n      this._global.setTimeout !==\n      ((_this$_fakeTimerAPIs = this._fakeTimerAPIs) === null ||\n      _this$_fakeTimerAPIs === void 0\n        ? void 0\n        : _this$_fakeTimerAPIs.setTimeout)\n    ) {\n      this._global.console.warn(\n        `A function to advance timers was called but the timers API is not ` +\n          `mocked with fake timers. Call \\`jest.useFakeTimers()\\` in this ` +\n          `test or enable fake timers globally by setting ` +\n          `\\`\"timers\": \"fake\"\\` in ` +\n          `the configuration file. This warning is likely a result of a ` +\n          `default configuration change in Jest 15.\\n\\n` +\n          `Release Blog Post: https://jestjs.io/blog/2016/09/01/jest-15.html\\n` +\n          `Stack Trace:\\n` +\n          (0, _jestMessageUtil().formatStackTrace)(\n            new Error().stack,\n            this._config,\n            {\n              noStackTrace: false\n            }\n          )\n      );\n    }\n  }\n\n  _createMocks() {\n    const fn = (\n      impl // @ts-expect-error TODO: figure out better typings here\n    ) => this._moduleMocker.fn().mockImplementation(impl);\n\n    const promisifiableFakeSetTimeout = fn(this._fakeSetTimeout.bind(this)); // @ts-expect-error TODO: figure out better typings here\n\n    promisifiableFakeSetTimeout[_util().default.promisify.custom] = (\n      delay,\n      arg\n    ) =>\n      new Promise(resolve => promisifiableFakeSetTimeout(resolve, delay, arg)); // TODO: add better typings; these are mocks, but typed as regular timers\n\n    this._fakeTimerAPIs = {\n      clearImmediate: fn(this._fakeClearImmediate.bind(this)),\n      clearInterval: fn(this._fakeClearTimer.bind(this)),\n      clearTimeout: fn(this._fakeClearTimer.bind(this)),\n      nextTick: fn(this._fakeNextTick.bind(this)),\n      // @ts-expect-error TODO: figure out better typings here\n      setImmediate: fn(this._fakeSetImmediate.bind(this)),\n      // @ts-expect-error TODO: figure out better typings here\n      setInterval: fn(this._fakeSetInterval.bind(this)),\n      // @ts-expect-error TODO: figure out better typings here\n      setTimeout: promisifiableFakeSetTimeout\n    };\n  }\n\n  _fakeClearTimer(timerRef) {\n    const uuid = this._timerConfig.refToId(timerRef);\n\n    if (uuid) {\n      this._timers.delete(String(uuid));\n    }\n  }\n\n  _fakeClearImmediate(uuid) {\n    this._immediates = this._immediates.filter(\n      immediate => immediate.uuid !== uuid\n    );\n  }\n\n  _fakeNextTick(callback, ...args) {\n    if (this._disposed) {\n      return;\n    }\n\n    const uuid = String(this._uuidCounter++);\n\n    this._ticks.push({\n      callback: () => callback.apply(null, args),\n      uuid\n    });\n\n    const cancelledTicks = this._cancelledTicks;\n\n    this._timerAPIs.nextTick(() => {\n      if (!cancelledTicks.hasOwnProperty(uuid)) {\n        // Callback may throw, so update the map prior calling.\n        cancelledTicks[uuid] = true;\n        callback.apply(null, args);\n      }\n    });\n  }\n\n  _fakeSetImmediate(callback, ...args) {\n    if (this._disposed) {\n      return null;\n    }\n\n    const uuid = String(this._uuidCounter++);\n\n    this._immediates.push({\n      callback: () => callback.apply(null, args),\n      uuid\n    });\n\n    this._timerAPIs.setImmediate(() => {\n      if (this._immediates.find(x => x.uuid === uuid)) {\n        try {\n          callback.apply(null, args);\n        } finally {\n          this._fakeClearImmediate(uuid);\n        }\n      }\n    });\n\n    return uuid;\n  }\n\n  _fakeSetInterval(callback, intervalDelay, ...args) {\n    if (this._disposed) {\n      return null;\n    }\n\n    if (intervalDelay == null) {\n      intervalDelay = 0;\n    }\n\n    const uuid = this._uuidCounter++;\n\n    this._timers.set(String(uuid), {\n      callback: () => callback.apply(null, args),\n      expiry: this._now + intervalDelay,\n      interval: intervalDelay,\n      type: 'interval'\n    });\n\n    return this._timerConfig.idToRef(uuid);\n  }\n\n  _fakeSetTimeout(callback, delay, ...args) {\n    if (this._disposed) {\n      return null;\n    } // eslint-disable-next-line no-bitwise\n\n    delay = Number(delay) | 0;\n    const uuid = this._uuidCounter++;\n\n    this._timers.set(String(uuid), {\n      callback: () => callback.apply(null, args),\n      expiry: this._now + delay,\n      interval: undefined,\n      type: 'timeout'\n    });\n\n    return this._timerConfig.idToRef(uuid);\n  }\n\n  _getNextTimerHandle() {\n    let nextTimerHandle = null;\n    let soonestTime = MS_IN_A_YEAR;\n\n    this._timers.forEach((timer, uuid) => {\n      if (timer.expiry < soonestTime) {\n        soonestTime = timer.expiry;\n        nextTimerHandle = uuid;\n      }\n    });\n\n    return nextTimerHandle;\n  }\n\n  _runTimerHandle(timerHandle) {\n    const timer = this._timers.get(timerHandle);\n\n    if (!timer) {\n      return;\n    }\n\n    switch (timer.type) {\n      case 'timeout':\n        const callback = timer.callback;\n\n        this._timers.delete(timerHandle);\n\n        callback();\n        break;\n\n      case 'interval':\n        timer.expiry = this._now + (timer.interval || 0);\n        timer.callback();\n        break;\n\n      default:\n        throw new Error('Unexpected timer type: ' + timer.type);\n    }\n  }\n}\n\nexports.default = FakeTimers;\n"]},"metadata":{},"sourceType":"script"}