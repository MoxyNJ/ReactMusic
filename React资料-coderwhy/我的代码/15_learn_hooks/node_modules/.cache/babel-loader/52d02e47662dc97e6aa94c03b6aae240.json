{"ast":null,"code":"'use strict';\n\nfunction nativeModule() {\n  const data = _interopRequireWildcard(require('module'));\n\n  nativeModule = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _url() {\n  const data = require('url');\n\n  _url = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _vm() {\n  const data = require('vm');\n\n  _vm = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _cjsModuleLexer() {\n  const data = require('cjs-module-lexer');\n\n  _cjsModuleLexer = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _collectV8Coverage() {\n  const data = require('collect-v8-coverage');\n\n  _collectV8Coverage = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _stripBom() {\n  const data = _interopRequireDefault(require('strip-bom'));\n\n  _stripBom = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fakeTimers() {\n  const data = require('@jest/fake-timers');\n\n  _fakeTimers = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _transform() {\n  const data = require('@jest/transform');\n\n  _transform = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestHasteMap() {\n  const data = _interopRequireDefault(require('jest-haste-map'));\n\n  _jestHasteMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMock() {\n  const data = _interopRequireDefault(require('jest-mock'));\n\n  _jestMock = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestResolve() {\n  const data = _interopRequireDefault(require('jest-resolve'));\n\n  _jestResolve = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = _interopRequireDefault(require('jest-snapshot'));\n\n  _jestSnapshot = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _cli = require('./cli');\n\nvar _args = require('./cli/args');\n\nvar _helpers = require('./helpers');\n\nvar _Object$fromEntries;\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nconst esmIsAvailable = typeof _vm().SourceTextModule === 'function';\nconst defaultTransformOptions = {\n  isInternalModule: false,\n  supportsDynamicImport: esmIsAvailable,\n  supportsExportNamespaceFrom: false,\n  supportsStaticESM: false,\n  supportsTopLevelAwait: false\n};\nconst OUTSIDE_JEST_VM_RESOLVE_OPTION = Symbol.for('OUTSIDE_JEST_VM_RESOLVE_OPTION');\nconst fromEntries = (_Object$fromEntries = Object.fromEntries) !== null && _Object$fromEntries !== void 0 ? _Object$fromEntries : function fromEntries(iterable) {\n  return [...iterable].reduce((obj, [key, val]) => {\n    obj[key] = val;\n    return obj;\n  }, {});\n};\nconst testTimeoutSymbol = Symbol.for('TEST_TIMEOUT_SYMBOL');\nconst retryTimesSymbol = Symbol.for('RETRY_TIMES');\nconst NODE_MODULES = path().sep + 'node_modules' + path().sep;\n\nconst getModuleNameMapper = config => {\n  if (Array.isArray(config.moduleNameMapper) && config.moduleNameMapper.length) {\n    return config.moduleNameMapper.map(([regex, moduleName]) => ({\n      moduleName,\n      regex: new RegExp(regex)\n    }));\n  }\n\n  return null;\n};\n\nconst unmockRegExpCache = new WeakMap();\nconst EVAL_RESULT_VARIABLE = 'Object.<anonymous>';\nconst runtimeSupportsVmModules = typeof _vm().SyntheticModule === 'function';\n\nconst supportsTopLevelAwait = runtimeSupportsVmModules && (() => {\n  try {\n    // eslint-disable-next-line no-new\n    new (_vm().SourceTextModule)('await Promise.resolve()');\n    return true;\n  } catch {\n    return false;\n  }\n})();\n\nclass Runtime {\n  constructor(config, environment, resolver, cacheFS = {}, coverageOptions, // TODO: Make mandatory in Jest 27\n  testPath) {\n    _defineProperty(this, '_cacheFS', void 0);\n\n    _defineProperty(this, '_config', void 0);\n\n    _defineProperty(this, '_coverageOptions', void 0);\n\n    _defineProperty(this, '_currentlyExecutingModulePath', void 0);\n\n    _defineProperty(this, '_environment', void 0);\n\n    _defineProperty(this, '_explicitShouldMock', void 0);\n\n    _defineProperty(this, '_fakeTimersImplementation', void 0);\n\n    _defineProperty(this, '_internalModuleRegistry', void 0);\n\n    _defineProperty(this, '_isCurrentlyExecutingManualMock', void 0);\n\n    _defineProperty(this, '_mainModule', void 0);\n\n    _defineProperty(this, '_mockFactories', void 0);\n\n    _defineProperty(this, '_mockMetaDataCache', void 0);\n\n    _defineProperty(this, '_mockRegistry', void 0);\n\n    _defineProperty(this, '_isolatedMockRegistry', void 0);\n\n    _defineProperty(this, '_moduleMocker', void 0);\n\n    _defineProperty(this, '_isolatedModuleRegistry', void 0);\n\n    _defineProperty(this, '_moduleRegistry', void 0);\n\n    _defineProperty(this, '_esmoduleRegistry', void 0);\n\n    _defineProperty(this, '_testPath', void 0);\n\n    _defineProperty(this, '_resolver', void 0);\n\n    _defineProperty(this, '_shouldAutoMock', void 0);\n\n    _defineProperty(this, '_shouldMockModuleCache', void 0);\n\n    _defineProperty(this, '_shouldUnmockTransitiveDependenciesCache', void 0);\n\n    _defineProperty(this, '_sourceMapRegistry', void 0);\n\n    _defineProperty(this, '_scriptTransformer', void 0);\n\n    _defineProperty(this, '_fileTransforms', void 0);\n\n    _defineProperty(this, '_v8CoverageInstrumenter', void 0);\n\n    _defineProperty(this, '_v8CoverageResult', void 0);\n\n    _defineProperty(this, '_transitiveShouldMock', void 0);\n\n    _defineProperty(this, '_unmockList', void 0);\n\n    _defineProperty(this, '_virtualMocks', void 0);\n\n    _defineProperty(this, '_moduleImplementation', void 0);\n\n    _defineProperty(this, 'jestObjectCaches', void 0);\n\n    _defineProperty(this, 'jestGlobals', void 0);\n\n    _defineProperty(this, 'unstable_shouldLoadAsEsm', _jestResolve().default.unstable_shouldLoadAsEsm);\n\n    this._cacheFS = new Map(Object.entries(cacheFS));\n    this._config = config;\n    this._coverageOptions = coverageOptions || {\n      changedFiles: undefined,\n      collectCoverage: false,\n      collectCoverageFrom: [],\n      collectCoverageOnlyFrom: undefined,\n      coverageProvider: 'babel',\n      sourcesRelatedToTestsInChangedFiles: undefined\n    };\n    this._currentlyExecutingModulePath = '';\n    this._environment = environment;\n    this._explicitShouldMock = new Map();\n    this._internalModuleRegistry = new Map();\n    this._isCurrentlyExecutingManualMock = null;\n    this._mainModule = null;\n    this._mockFactories = new Map();\n    this._mockRegistry = new Map(); // during setup, this cannot be null (and it's fine to explode if it is)\n\n    this._moduleMocker = this._environment.moduleMocker;\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n    this._moduleRegistry = new Map();\n    this._esmoduleRegistry = new Map();\n    this._testPath = testPath;\n    this._resolver = resolver;\n    this._scriptTransformer = new (_transform().ScriptTransformer)(config);\n    this._shouldAutoMock = config.automock;\n    this._sourceMapRegistry = new Map();\n    this._fileTransforms = new Map();\n    this._virtualMocks = new Map();\n    this.jestObjectCaches = new Map();\n    this._mockMetaDataCache = new Map();\n    this._shouldMockModuleCache = new Map();\n    this._shouldUnmockTransitiveDependenciesCache = new Map();\n    this._transitiveShouldMock = new Map();\n    this._fakeTimersImplementation = config.timers === 'modern' ? this._environment.fakeTimersModern : this._environment.fakeTimers;\n    this._unmockList = unmockRegExpCache.get(config);\n\n    if (!this._unmockList && config.unmockedModulePathPatterns) {\n      this._unmockList = new RegExp(config.unmockedModulePathPatterns.join('|'));\n      unmockRegExpCache.set(config, this._unmockList);\n    }\n\n    if (config.automock) {\n      const virtualMocks = fromEntries(this._virtualMocks);\n      config.setupFiles.forEach(filePath => {\n        if (filePath && filePath.includes(NODE_MODULES)) {\n          const moduleID = this._resolver.getModuleID(virtualMocks, filePath);\n\n          this._transitiveShouldMock.set(moduleID, false);\n        }\n      });\n    }\n\n    this.resetModules();\n  }\n\n  static createContext(config, options) {\n    (0, _jestUtil().createDirectory)(config.cacheDirectory);\n    const instance = Runtime.createHasteMap(config, {\n      console: options.console,\n      maxWorkers: options.maxWorkers,\n      resetCache: !config.cache,\n      watch: options.watch,\n      watchman: options.watchman\n    });\n    return instance.build().then(hasteMap => ({\n      config,\n      hasteFS: hasteMap.hasteFS,\n      moduleMap: hasteMap.moduleMap,\n      resolver: Runtime.createResolver(config, hasteMap.moduleMap)\n    }), error => {\n      throw error;\n    });\n  }\n\n  static createHasteMap(config, options) {\n    const ignorePatternParts = [...config.modulePathIgnorePatterns, ...(options && options.watch ? config.watchPathIgnorePatterns : []), config.cacheDirectory.startsWith(config.rootDir + path().sep) && config.cacheDirectory].filter(Boolean);\n    const ignorePattern = ignorePatternParts.length > 0 ? new RegExp(ignorePatternParts.join('|')) : undefined;\n    return new (_jestHasteMap().default)({\n      cacheDirectory: config.cacheDirectory,\n      computeSha1: config.haste.computeSha1,\n      console: options && options.console,\n      dependencyExtractor: config.dependencyExtractor,\n      extensions: [_jestSnapshot().default.EXTENSION].concat(config.moduleFileExtensions),\n      hasteImplModulePath: config.haste.hasteImplModulePath,\n      ignorePattern,\n      maxWorkers: options && options.maxWorkers || 1,\n      mocksPattern: (0, _jestRegexUtil().escapePathForRegex)(path().sep + '__mocks__' + path().sep),\n      name: config.name,\n      platforms: config.haste.platforms || ['ios', 'android'],\n      resetCache: options && options.resetCache,\n      retainAllFiles: false,\n      rootDir: config.rootDir,\n      roots: config.roots,\n      throwOnModuleCollision: config.haste.throwOnModuleCollision,\n      useWatchman: options && options.watchman,\n      watch: options && options.watch\n    });\n  }\n\n  static createResolver(config, moduleMap) {\n    return new (_jestResolve().default)(moduleMap, {\n      defaultPlatform: config.haste.defaultPlatform,\n      extensions: config.moduleFileExtensions.map(extension => '.' + extension),\n      hasCoreModules: true,\n      moduleDirectories: config.moduleDirectories,\n      moduleNameMapper: getModuleNameMapper(config),\n      modulePaths: config.modulePaths,\n      platforms: config.haste.platforms,\n      resolver: config.resolver,\n      rootDir: config.rootDir\n    });\n  }\n\n  static runCLI(args, info) {\n    return (0, _cli.run)(args, info);\n  }\n\n  static getCLIOptions() {\n    return _args.options;\n  } // unstable as it should be replaced by https://github.com/nodejs/modules/issues/393, and we don't want people to use it\n\n\n  async loadEsmModule(modulePath, query = '') {\n    const cacheKey = modulePath + query;\n\n    if (!this._esmoduleRegistry.has(cacheKey)) {\n      invariant(typeof this._environment.getVmContext === 'function', 'ES Modules are only supported if your test environment has the `getVmContext` function');\n\n      const context = this._environment.getVmContext();\n\n      invariant(context);\n\n      if (this._resolver.isCoreModule(modulePath)) {\n        const core = await this._importCoreModule(modulePath, context);\n\n        this._esmoduleRegistry.set(cacheKey, core);\n\n        return core;\n      }\n\n      const transformedCode = this.transformFile(modulePath, {\n        isInternalModule: false,\n        supportsDynamicImport: true,\n        supportsExportNamespaceFrom: true,\n        supportsStaticESM: true,\n        supportsTopLevelAwait\n      });\n      const module = new (_vm().SourceTextModule)(transformedCode, {\n        context,\n        identifier: modulePath,\n        importModuleDynamically: (specifier, referencingModule) => this.linkModules(specifier, referencingModule.identifier, referencingModule.context),\n\n        initializeImportMeta(meta) {\n          meta.url = (0, _url().pathToFileURL)(modulePath).href;\n        }\n\n      });\n\n      this._esmoduleRegistry.set(cacheKey, // we wanna put the linking promise in the cache so modules loaded in\n      // parallel can all await it. We then await it synchronously below, so\n      // we shouldn't get any unhandled rejections\n      module.link((specifier, referencingModule) => this.linkModules(specifier, referencingModule.identifier, referencingModule.context)).then(() => module.evaluate()).then(() => module));\n    }\n\n    const module = this._esmoduleRegistry.get(cacheKey);\n\n    invariant(module);\n    return module;\n  }\n\n  linkModules(specifier, referencingIdentifier, context) {\n    if (specifier === '@jest/globals') {\n      const fromCache = this._esmoduleRegistry.get('@jest/globals');\n\n      if (fromCache) {\n        return fromCache;\n      }\n\n      const globals = this.getGlobalsForEsm(referencingIdentifier, context);\n\n      this._esmoduleRegistry.set('@jest/globals', globals);\n\n      return globals;\n    }\n\n    if (specifier.startsWith('file://')) {\n      specifier = (0, _url().fileURLToPath)(specifier);\n    }\n\n    const [path, query] = specifier.split('?');\n\n    const resolved = this._resolveModule(referencingIdentifier, path);\n\n    if (this._resolver.isCoreModule(resolved) || this.unstable_shouldLoadAsEsm(resolved)) {\n      return this.loadEsmModule(resolved, query);\n    }\n\n    return this.loadCjsAsEsm(referencingIdentifier, resolved, context);\n  }\n\n  async unstable_importModule(from, moduleName) {\n    invariant(runtimeSupportsVmModules, 'You need to run with a version of node that supports ES Modules in the VM API.');\n    const [path, query] = (moduleName !== null && moduleName !== void 0 ? moduleName : '').split('?');\n\n    const modulePath = this._resolveModule(from, path);\n\n    return this.loadEsmModule(modulePath, query);\n  }\n\n  loadCjsAsEsm(from, modulePath, context) {\n    // CJS loaded via `import` should share cache with other CJS: https://github.com/nodejs/modules/issues/503\n    const cjs = this.requireModuleOrMock(from, modulePath);\n\n    const transformedCode = this._fileTransforms.get(modulePath);\n\n    let cjsExports = [];\n\n    if (transformedCode) {\n      const {\n        exports\n      } = (0, _cjsModuleLexer().parse)(transformedCode.code);\n      cjsExports = exports.filter(exportName => {\n        // we don't wanna respect any exports _names_ default as a named export\n        if (exportName === 'default') {\n          return false;\n        }\n\n        return Object.hasOwnProperty.call(cjs, exportName);\n      });\n    }\n\n    const module = new (_vm().SyntheticModule)([...cjsExports, 'default'], function () {\n      cjsExports.forEach(exportName => {\n        // @ts-expect-error\n        this.setExport(exportName, cjs[exportName]);\n      }); // @ts-expect-error: TS doesn't know what `this` is\n\n      this.setExport('default', cjs);\n    }, {\n      context,\n      identifier: modulePath\n    });\n    return evaluateSyntheticModule(module);\n  }\n\n  requireModule(from, moduleName, options, isRequireActual) {\n    const moduleID = this._resolver.getModuleID(fromEntries(this._virtualMocks), from, moduleName);\n\n    let modulePath; // Some old tests rely on this mocking behavior. Ideally we'll change this\n    // to be more explicit.\n\n    const moduleResource = moduleName && this._resolver.getModule(moduleName);\n\n    const manualMock = moduleName && this._resolver.getMockModule(from, moduleName);\n\n    if (!(options === null || options === void 0 ? void 0 : options.isInternalModule) && !isRequireActual && !moduleResource && manualMock && manualMock !== this._isCurrentlyExecutingManualMock && this._explicitShouldMock.get(moduleID) !== false) {\n      modulePath = manualMock;\n    }\n\n    if (moduleName && this._resolver.isCoreModule(moduleName)) {\n      return this._requireCoreModule(moduleName);\n    }\n\n    if (!modulePath) {\n      modulePath = this._resolveModule(from, moduleName);\n    }\n\n    let moduleRegistry;\n\n    if (options === null || options === void 0 ? void 0 : options.isInternalModule) {\n      moduleRegistry = this._internalModuleRegistry;\n    } else {\n      if (this._moduleRegistry.get(modulePath) || !this._isolatedModuleRegistry) {\n        moduleRegistry = this._moduleRegistry;\n      } else {\n        moduleRegistry = this._isolatedModuleRegistry;\n      }\n    }\n\n    const module = moduleRegistry.get(modulePath);\n\n    if (module) {\n      return module.exports;\n    } // We must register the pre-allocated module object first so that any\n    // circular dependencies that may arise while evaluating the module can\n    // be satisfied.\n\n\n    const localModule = {\n      children: [],\n      exports: {},\n      filename: modulePath,\n      id: modulePath,\n      loaded: false,\n      path: path().dirname(modulePath)\n    };\n    moduleRegistry.set(modulePath, localModule);\n\n    this._loadModule(localModule, from, moduleName, modulePath, options, moduleRegistry);\n\n    return localModule.exports;\n  }\n\n  requireInternalModule(from, to) {\n    if (to) {\n      const outsideJestVmPath = (0, _helpers.decodePossibleOutsideJestVmPath)(to);\n\n      if (outsideJestVmPath) {\n        return require(outsideJestVmPath);\n      }\n    }\n\n    return this.requireModule(from, to, {\n      isInternalModule: true,\n      supportsDynamicImport: esmIsAvailable,\n      supportsExportNamespaceFrom: false,\n      supportsStaticESM: false,\n      supportsTopLevelAwait: false\n    });\n  }\n\n  requireActual(from, moduleName) {\n    return this.requireModule(from, moduleName, undefined, true);\n  }\n\n  requireMock(from, moduleName) {\n    const moduleID = this._resolver.getModuleID(fromEntries(this._virtualMocks), from, moduleName);\n\n    if (this._isolatedMockRegistry && this._isolatedMockRegistry.get(moduleID)) {\n      return this._isolatedMockRegistry.get(moduleID);\n    } else if (this._mockRegistry.get(moduleID)) {\n      return this._mockRegistry.get(moduleID);\n    }\n\n    const mockRegistry = this._isolatedMockRegistry || this._mockRegistry;\n\n    if (this._mockFactories.has(moduleID)) {\n      // has check above makes this ok\n      const module = this._mockFactories.get(moduleID)();\n\n      mockRegistry.set(moduleID, module);\n      return module;\n    }\n\n    const manualMockOrStub = this._resolver.getMockModule(from, moduleName);\n\n    let modulePath = this._resolver.getMockModule(from, moduleName) || this._resolveModule(from, moduleName);\n\n    let isManualMock = manualMockOrStub && !this._resolver.resolveStubModuleName(from, moduleName);\n\n    if (!isManualMock) {\n      // If the actual module file has a __mocks__ dir sitting immediately next\n      // to it, look to see if there is a manual mock for this file.\n      //\n      // subDir1/my_module.js\n      // subDir1/__mocks__/my_module.js\n      // subDir2/my_module.js\n      // subDir2/__mocks__/my_module.js\n      //\n      // Where some other module does a relative require into each of the\n      // respective subDir{1,2} directories and expects a manual mock\n      // corresponding to that particular my_module.js file.\n      const moduleDir = path().dirname(modulePath);\n      const moduleFileName = path().basename(modulePath);\n      const potentialManualMock = path().join(moduleDir, '__mocks__', moduleFileName);\n\n      if (fs().existsSync(potentialManualMock)) {\n        isManualMock = true;\n        modulePath = potentialManualMock;\n      }\n    }\n\n    if (isManualMock) {\n      const localModule = {\n        children: [],\n        exports: {},\n        filename: modulePath,\n        id: modulePath,\n        loaded: false,\n        path: path().dirname(modulePath)\n      };\n\n      this._loadModule(localModule, from, moduleName, modulePath, undefined, mockRegistry);\n\n      mockRegistry.set(moduleID, localModule.exports);\n    } else {\n      // Look for a real module to generate an automock from\n      mockRegistry.set(moduleID, this._generateMock(from, moduleName));\n    }\n\n    return mockRegistry.get(moduleID);\n  }\n\n  _loadModule(localModule, from, moduleName, modulePath, options, moduleRegistry) {\n    if (path().extname(modulePath) === '.json') {\n      const text = (0, _stripBom().default)(this.readFile(modulePath));\n\n      const transformedFile = this._scriptTransformer.transformJson(modulePath, this._getFullTransformationOptions(options), text);\n\n      localModule.exports = this._environment.global.JSON.parse(transformedFile);\n    } else if (path().extname(modulePath) === '.node') {\n      localModule.exports = require(modulePath);\n    } else {\n      // Only include the fromPath if a moduleName is given. Else treat as root.\n      const fromPath = moduleName ? from : null;\n\n      this._execModule(localModule, options, moduleRegistry, fromPath);\n    }\n\n    localModule.loaded = true;\n  }\n\n  _getFullTransformationOptions(options = defaultTransformOptions) {\n    return { ...options,\n      ...this._coverageOptions\n    };\n  }\n\n  requireModuleOrMock(from, moduleName) {\n    // this module is unmockable\n    if (moduleName === '@jest/globals') {\n      // @ts-expect-error: we don't care that it's not assignable to T\n      return this.getGlobalsForCjs(from);\n    }\n\n    try {\n      if (this._shouldMock(from, moduleName)) {\n        return this.requireMock(from, moduleName);\n      } else {\n        return this.requireModule(from, moduleName);\n      }\n    } catch (e) {\n      const moduleNotFound = _jestResolve().default.tryCastModuleNotFoundError(e);\n\n      if (moduleNotFound) {\n        if (moduleNotFound.siblingWithSimilarExtensionFound === null || moduleNotFound.siblingWithSimilarExtensionFound === undefined) {\n          moduleNotFound.hint = (0, _helpers.findSiblingsWithFileExtension)(this._config.moduleFileExtensions, from, moduleNotFound.moduleName || moduleName);\n          moduleNotFound.siblingWithSimilarExtensionFound = Boolean(moduleNotFound.hint);\n        }\n\n        moduleNotFound.buildMessage(this._config.rootDir);\n        throw moduleNotFound;\n      }\n\n      throw e;\n    }\n  }\n\n  isolateModules(fn) {\n    if (this._isolatedModuleRegistry || this._isolatedMockRegistry) {\n      throw new Error('isolateModules cannot be nested inside another isolateModules.');\n    }\n\n    this._isolatedModuleRegistry = new Map();\n    this._isolatedMockRegistry = new Map();\n\n    try {\n      fn();\n    } finally {\n      var _this$_isolatedModule, _this$_isolatedMockRe; // might be cleared within the callback\n\n\n      (_this$_isolatedModule = this._isolatedModuleRegistry) === null || _this$_isolatedModule === void 0 ? void 0 : _this$_isolatedModule.clear();\n      (_this$_isolatedMockRe = this._isolatedMockRegistry) === null || _this$_isolatedMockRe === void 0 ? void 0 : _this$_isolatedMockRe.clear();\n      this._isolatedModuleRegistry = null;\n      this._isolatedMockRegistry = null;\n    }\n  }\n\n  resetModules() {\n    var _this$_isolatedModule2, _this$_isolatedMockRe2;\n\n    (_this$_isolatedModule2 = this._isolatedModuleRegistry) === null || _this$_isolatedModule2 === void 0 ? void 0 : _this$_isolatedModule2.clear();\n    (_this$_isolatedMockRe2 = this._isolatedMockRegistry) === null || _this$_isolatedMockRe2 === void 0 ? void 0 : _this$_isolatedMockRe2.clear();\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n\n    this._mockRegistry.clear();\n\n    this._moduleRegistry.clear();\n\n    this._esmoduleRegistry.clear();\n\n    if (this._environment) {\n      if (this._environment.global) {\n        const envGlobal = this._environment.global;\n        Object.keys(envGlobal).forEach(key => {\n          const globalMock = envGlobal[key];\n\n          if ((typeof globalMock === 'object' && globalMock !== null || typeof globalMock === 'function') && globalMock._isMockFunction === true) {\n            globalMock.mockClear();\n          }\n        });\n      }\n\n      if (this._environment.fakeTimers) {\n        this._environment.fakeTimers.clearAllTimers();\n      }\n    }\n  }\n\n  async collectV8Coverage() {\n    this._v8CoverageInstrumenter = new (_collectV8Coverage().CoverageInstrumenter)();\n    await this._v8CoverageInstrumenter.startInstrumenting();\n  }\n\n  async stopCollectingV8Coverage() {\n    if (!this._v8CoverageInstrumenter) {\n      throw new Error('You need to call `collectV8Coverage` first.');\n    }\n\n    this._v8CoverageResult = await this._v8CoverageInstrumenter.stopInstrumenting();\n  }\n\n  getAllCoverageInfoCopy() {\n    return (0, _jestUtil().deepCyclicCopy)(this._environment.global.__coverage__);\n  }\n\n  getAllV8CoverageInfoCopy() {\n    if (!this._v8CoverageResult) {\n      throw new Error('You need to `stopCollectingV8Coverage` first');\n    }\n\n    return this._v8CoverageResult.filter(res => res.url.startsWith('file://')).map(res => ({ ...res,\n      url: (0, _url().fileURLToPath)(res.url)\n    })).filter((res // TODO: will this work on windows? It might be better if `shouldInstrument` deals with it anyways\n    ) => res.url.startsWith(this._config.rootDir) && this._fileTransforms.has(res.url) && (0, _transform().shouldInstrument)(res.url, this._coverageOptions, this._config)).map(result => {\n      const transformedFile = this._fileTransforms.get(result.url);\n\n      return {\n        codeTransformResult: transformedFile,\n        result\n      };\n    });\n  } // TODO - remove in Jest 27\n\n\n  getSourceMapInfo(_coveredFiles) {\n    return {};\n  }\n\n  getSourceMaps() {\n    return fromEntries(this._sourceMapRegistry);\n  }\n\n  setMock(from, moduleName, mockFactory, options) {\n    if (options === null || options === void 0 ? void 0 : options.virtual) {\n      const mockPath = this._resolver.getModulePath(from, moduleName);\n\n      this._virtualMocks.set(mockPath, true);\n    }\n\n    const moduleID = this._resolver.getModuleID(fromEntries(this._virtualMocks), from, moduleName);\n\n    this._explicitShouldMock.set(moduleID, true);\n\n    this._mockFactories.set(moduleID, mockFactory);\n  }\n\n  restoreAllMocks() {\n    this._moduleMocker.restoreAllMocks();\n  }\n\n  resetAllMocks() {\n    this._moduleMocker.resetAllMocks();\n  }\n\n  clearAllMocks() {\n    this._moduleMocker.clearAllMocks();\n  }\n\n  teardown() {\n    this.restoreAllMocks();\n    this.resetAllMocks();\n    this.resetModules();\n\n    this._internalModuleRegistry.clear();\n\n    this._mainModule = null;\n\n    this._mockFactories.clear();\n\n    this._mockMetaDataCache.clear();\n\n    this._shouldMockModuleCache.clear();\n\n    this._shouldUnmockTransitiveDependenciesCache.clear();\n\n    this._explicitShouldMock.clear();\n\n    this._transitiveShouldMock.clear();\n\n    this._virtualMocks.clear();\n\n    this._cacheFS.clear();\n\n    this._unmockList = undefined;\n\n    this._sourceMapRegistry.clear();\n\n    this._fileTransforms.clear();\n\n    this.jestObjectCaches.clear();\n    this._v8CoverageResult = [];\n    this._v8CoverageInstrumenter = undefined;\n    this._moduleImplementation = undefined;\n  }\n\n  _resolveModule(from, to) {\n    return to ? this._resolver.resolveModule(from, to) : from;\n  }\n\n  _requireResolve(from, moduleName, options = {}) {\n    if (moduleName == null) {\n      throw new Error('The first argument to require.resolve must be a string. Received null or undefined.');\n    }\n\n    const {\n      paths\n    } = options;\n\n    if (paths) {\n      for (const p of paths) {\n        const absolutePath = path().resolve(from, '..', p);\n\n        const module = this._resolver.resolveModuleFromDirIfExists(absolutePath, moduleName, // required to also resolve files without leading './' directly in the path\n        {\n          paths: [absolutePath]\n        });\n\n        if (module) {\n          return module;\n        }\n      }\n\n      throw new (_jestResolve().default.ModuleNotFoundError)(`Cannot resolve module '${moduleName}' from paths ['${paths.join(\"', '\")}'] from ${from}`);\n    }\n\n    try {\n      return this._resolveModule(from, moduleName);\n    } catch (err) {\n      const module = this._resolver.getMockModule(from, moduleName);\n\n      if (module) {\n        return module;\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  _requireResolvePaths(from, moduleName) {\n    if (moduleName == null) {\n      throw new Error('The first argument to require.resolve.paths must be a string. Received null or undefined.');\n    }\n\n    if (!moduleName.length) {\n      throw new Error('The first argument to require.resolve.paths must not be the empty string.');\n    }\n\n    if (moduleName[0] === '.') {\n      return [path().resolve(from, '..')];\n    }\n\n    if (this._resolver.isCoreModule(moduleName)) {\n      return null;\n    }\n\n    return this._resolver.getModulePaths(path().resolve(from, '..'));\n  }\n\n  _execModule(localModule, options, moduleRegistry, from) {\n    // If the environment was disposed, prevent this module from being executed.\n    if (!this._environment.global) {\n      return;\n    }\n\n    const module = localModule;\n    const filename = module.filename;\n    const lastExecutingModulePath = this._currentlyExecutingModulePath;\n    this._currentlyExecutingModulePath = filename;\n    const origCurrExecutingManualMock = this._isCurrentlyExecutingManualMock;\n    this._isCurrentlyExecutingManualMock = filename;\n    module.children = [];\n    Object.defineProperty(module, 'parent', {\n      enumerable: true,\n\n      get() {\n        const key = from || '';\n        return moduleRegistry.get(key) || null;\n      }\n\n    });\n    module.paths = this._resolver.getModulePaths(module.path);\n    Object.defineProperty(module, 'require', {\n      value: this._createRequireImplementation(module, options)\n    });\n    const transformedCode = this.transformFile(filename, options);\n    let compiledFunction = null;\n    const script = this.createScriptFromCode(transformedCode, filename);\n    let runScript = null; // Use this if available instead of deprecated `JestEnvironment.runScript`\n\n    if (typeof this._environment.getVmContext === 'function') {\n      const vmContext = this._environment.getVmContext();\n\n      if (vmContext) {\n        runScript = script.runInContext(vmContext, {\n          filename\n        });\n      }\n    } else {\n      runScript = this._environment.runScript(script);\n    }\n\n    if (runScript !== null) {\n      compiledFunction = runScript[EVAL_RESULT_VARIABLE];\n    }\n\n    if (compiledFunction === null) {\n      this._logFormattedReferenceError('You are trying to `import` a file after the Jest environment has been torn down.');\n\n      process.exitCode = 1;\n      return;\n    }\n\n    const jestObject = this._createJestObjectFor(filename);\n\n    this.jestObjectCaches.set(filename, jestObject);\n    const lastArgs = [this._config.injectGlobals ? jestObject : undefined, // jest object\n    ...this._config.extraGlobals.map(globalVariable => {\n      if (this._environment.global[globalVariable]) {\n        return this._environment.global[globalVariable];\n      }\n\n      throw new Error(`You have requested '${globalVariable}' as a global variable, but it was not present. Please check your config or your global environment.`);\n    })];\n\n    if (!this._mainModule && filename === this._testPath) {\n      this._mainModule = module;\n    }\n\n    Object.defineProperty(module, 'main', {\n      enumerable: true,\n      value: this._mainModule\n    });\n\n    try {\n      compiledFunction.call(module.exports, module, // module object\n      module.exports, // module exports\n      module.require, // require implementation\n      module.path, // __dirname\n      module.filename, // __filename\n      this._environment.global, // global object\n      // @ts-expect-error\n      ...lastArgs.filter(notEmpty));\n    } catch (error) {\n      this.handleExecutionError(error, module);\n    }\n\n    this._isCurrentlyExecutingManualMock = origCurrExecutingManualMock;\n    this._currentlyExecutingModulePath = lastExecutingModulePath;\n  }\n\n  transformFile(filename, options) {\n    const source = this.readFile(filename);\n\n    if (options === null || options === void 0 ? void 0 : options.isInternalModule) {\n      return source;\n    }\n\n    const transformedFile = this._scriptTransformer.transform(filename, this._getFullTransformationOptions(options), source);\n\n    this._fileTransforms.set(filename, { ...transformedFile,\n      wrapperLength: this.constructModuleWrapperStart().length\n    });\n\n    if (transformedFile.sourceMapPath) {\n      this._sourceMapRegistry.set(filename, transformedFile.sourceMapPath);\n    }\n\n    return transformedFile.code;\n  }\n\n  createScriptFromCode(scriptSource, filename) {\n    try {\n      const scriptFilename = this._resolver.isCoreModule(filename) ? `jest-nodejs-core-${filename}` : filename;\n      return new (_vm().Script)(this.wrapCodeInModuleWrapper(scriptSource), {\n        displayErrors: true,\n        filename: scriptFilename,\n        // @ts-expect-error: Experimental ESM API\n        importModuleDynamically: specifier => {\n          var _this$_environment$ge, _this$_environment;\n\n          const context = (_this$_environment$ge = (_this$_environment = this._environment).getVmContext) === null || _this$_environment$ge === void 0 ? void 0 : _this$_environment$ge.call(_this$_environment);\n          invariant(context);\n          return this.linkModules(specifier, scriptFilename, context);\n        }\n      });\n    } catch (e) {\n      throw (0, _transform().handlePotentialSyntaxError)(e);\n    }\n  }\n\n  _requireCoreModule(moduleName) {\n    if (moduleName === 'process') {\n      return this._environment.global.process;\n    }\n\n    if (moduleName === 'module') {\n      return this._getMockedNativeModule();\n    }\n\n    return require(moduleName);\n  }\n\n  _importCoreModule(moduleName, context) {\n    const required = this._requireCoreModule(moduleName);\n\n    const module = new (_vm().SyntheticModule)(['default', ...Object.keys(required)], function () {\n      // @ts-expect-error: TS doesn't know what `this` is\n      this.setExport('default', required);\n      Object.entries(required).forEach(([key, value]) => {\n        // @ts-expect-error: TS doesn't know what `this` is\n        this.setExport(key, value);\n      });\n    }, // should identifier be `node://${moduleName}`?\n    {\n      context,\n      identifier: moduleName\n    });\n    return evaluateSyntheticModule(module);\n  }\n\n  _getMockedNativeModule() {\n    if (this._moduleImplementation) {\n      return this._moduleImplementation;\n    }\n\n    const createRequire = modulePath => {\n      const filename = typeof modulePath === 'string' ? modulePath.startsWith('file:///') ? (0, _url().fileURLToPath)(new (_url().URL)(modulePath)) : modulePath : (0, _url().fileURLToPath)(modulePath);\n\n      if (!path().isAbsolute(filename)) {\n        const error = new TypeError(`The argument 'filename' must be a file URL object, file URL string, or absolute path string. Received '${filename}'`); // @ts-expect-error\n\n        error.code = 'ERR_INVALID_ARG_TYPE';\n        throw error;\n      }\n\n      return this._createRequireImplementation({\n        children: [],\n        exports: {},\n        filename,\n        id: filename,\n        loaded: false,\n        path: path().dirname(filename)\n      });\n    }; // should we implement the class ourselves?\n\n\n    class Module extends nativeModule().Module {}\n\n    Object.entries(nativeModule().Module).forEach(([key, value]) => {\n      // @ts-expect-error\n      Module[key] = value;\n    });\n    Module.Module = Module;\n\n    if ('createRequire' in nativeModule()) {\n      Module.createRequire = createRequire;\n    }\n\n    if ('createRequireFromPath' in nativeModule()) {\n      Module.createRequireFromPath = function createRequireFromPath(filename) {\n        if (typeof filename !== 'string') {\n          const error = new TypeError(`The argument 'filename' must be string. Received '${filename}'.${filename instanceof _url().URL ? ' Use createRequire for URL filename.' : ''}`); // @ts-expect-error\n\n          error.code = 'ERR_INVALID_ARG_TYPE';\n          throw error;\n        }\n\n        return createRequire(filename);\n      };\n    }\n\n    if ('syncBuiltinESMExports' in nativeModule()) {\n      Module.syncBuiltinESMExports = function syncBuiltinESMExports() {};\n    }\n\n    this._moduleImplementation = Module;\n    return Module;\n  }\n\n  _generateMock(from, moduleName) {\n    const modulePath = this._resolver.resolveStubModuleName(from, moduleName) || this._resolveModule(from, moduleName);\n\n    if (!this._mockMetaDataCache.has(modulePath)) {\n      // This allows us to handle circular dependencies while generating an\n      // automock\n      this._mockMetaDataCache.set(modulePath, this._moduleMocker.getMetadata({}) || {}); // In order to avoid it being possible for automocking to potentially\n      // cause side-effects within the module environment, we need to execute\n      // the module in isolation. This could cause issues if the module being\n      // mocked has calls into side-effectful APIs on another module.\n\n\n      const origMockRegistry = this._mockRegistry;\n      const origModuleRegistry = this._moduleRegistry;\n      this._mockRegistry = new Map();\n      this._moduleRegistry = new Map();\n      const moduleExports = this.requireModule(from, moduleName); // Restore the \"real\" module/mock registries\n\n      this._mockRegistry = origMockRegistry;\n      this._moduleRegistry = origModuleRegistry;\n\n      const mockMetadata = this._moduleMocker.getMetadata(moduleExports);\n\n      if (mockMetadata == null) {\n        throw new Error(`Failed to get mock metadata: ${modulePath}\\n\\n` + `See: https://jestjs.io/docs/manual-mocks.html#content`);\n      }\n\n      this._mockMetaDataCache.set(modulePath, mockMetadata);\n    }\n\n    return this._moduleMocker.generateFromMetadata( // added above if missing\n    this._mockMetaDataCache.get(modulePath));\n  }\n\n  _shouldMock(from, moduleName) {\n    const explicitShouldMock = this._explicitShouldMock;\n\n    const moduleID = this._resolver.getModuleID(fromEntries(this._virtualMocks), from, moduleName);\n\n    const key = from + path().delimiter + moduleID;\n\n    if (explicitShouldMock.has(moduleID)) {\n      // guaranteed by `has` above\n      return explicitShouldMock.get(moduleID);\n    }\n\n    if (!this._shouldAutoMock || this._resolver.isCoreModule(moduleName) || this._shouldUnmockTransitiveDependenciesCache.get(key)) {\n      return false;\n    }\n\n    if (this._shouldMockModuleCache.has(moduleID)) {\n      // guaranteed by `has` above\n      return this._shouldMockModuleCache.get(moduleID);\n    }\n\n    let modulePath;\n\n    try {\n      modulePath = this._resolveModule(from, moduleName);\n    } catch (e) {\n      const manualMock = this._resolver.getMockModule(from, moduleName);\n\n      if (manualMock) {\n        this._shouldMockModuleCache.set(moduleID, true);\n\n        return true;\n      }\n\n      throw e;\n    }\n\n    if (this._unmockList && this._unmockList.test(modulePath)) {\n      this._shouldMockModuleCache.set(moduleID, false);\n\n      return false;\n    } // transitive unmocking for package managers that store flat packages (npm3)\n\n\n    const currentModuleID = this._resolver.getModuleID(fromEntries(this._virtualMocks), from);\n\n    if (this._transitiveShouldMock.get(currentModuleID) === false || from.includes(NODE_MODULES) && modulePath.includes(NODE_MODULES) && (this._unmockList && this._unmockList.test(from) || explicitShouldMock.get(currentModuleID) === false)) {\n      this._transitiveShouldMock.set(moduleID, false);\n\n      this._shouldUnmockTransitiveDependenciesCache.set(key, true);\n\n      return false;\n    }\n\n    this._shouldMockModuleCache.set(moduleID, true);\n\n    return true;\n  }\n\n  _createRequireImplementation(from, options) {\n    const resolve = (moduleName, resolveOptions) => {\n      const resolved = this._requireResolve(from.filename, moduleName, resolveOptions);\n\n      if ((resolveOptions === null || resolveOptions === void 0 ? void 0 : resolveOptions[OUTSIDE_JEST_VM_RESOLVE_OPTION]) && (options === null || options === void 0 ? void 0 : options.isInternalModule)) {\n        return (0, _helpers.createOutsideJestVmPath)(resolved);\n      }\n\n      return resolved;\n    };\n\n    resolve.paths = moduleName => this._requireResolvePaths(from.filename, moduleName);\n\n    const moduleRequire = (options === null || options === void 0 ? void 0 : options.isInternalModule) ? moduleName => this.requireInternalModule(from.filename, moduleName) : this.requireModuleOrMock.bind(this, from.filename);\n    moduleRequire.extensions = Object.create(null);\n    moduleRequire.resolve = resolve;\n\n    moduleRequire.cache = (() => {\n      // TODO: consider warning somehow that this does nothing. We should support deletions, anyways\n      const notPermittedMethod = () => true;\n\n      return new Proxy(Object.create(null), {\n        defineProperty: notPermittedMethod,\n        deleteProperty: notPermittedMethod,\n        get: (_target, key) => typeof key === 'string' ? this._moduleRegistry.get(key) : undefined,\n\n        getOwnPropertyDescriptor() {\n          return {\n            configurable: true,\n            enumerable: true\n          };\n        },\n\n        has: (_target, key) => typeof key === 'string' && this._moduleRegistry.has(key),\n        ownKeys: () => Array.from(this._moduleRegistry.keys()),\n        set: notPermittedMethod\n      });\n    })();\n\n    Object.defineProperty(moduleRequire, 'main', {\n      enumerable: true,\n      value: this._mainModule\n    });\n    return moduleRequire;\n  }\n\n  _createJestObjectFor(from) {\n    const disableAutomock = () => {\n      this._shouldAutoMock = false;\n      return jestObject;\n    };\n\n    const enableAutomock = () => {\n      this._shouldAutoMock = true;\n      return jestObject;\n    };\n\n    const unmock = moduleName => {\n      const moduleID = this._resolver.getModuleID(fromEntries(this._virtualMocks), from, moduleName);\n\n      this._explicitShouldMock.set(moduleID, false);\n\n      return jestObject;\n    };\n\n    const deepUnmock = moduleName => {\n      const moduleID = this._resolver.getModuleID(fromEntries(this._virtualMocks), from, moduleName);\n\n      this._explicitShouldMock.set(moduleID, false);\n\n      this._transitiveShouldMock.set(moduleID, false);\n\n      return jestObject;\n    };\n\n    const mock = (moduleName, mockFactory, options) => {\n      if (mockFactory !== undefined) {\n        return setMockFactory(moduleName, mockFactory, options);\n      }\n\n      const moduleID = this._resolver.getModuleID(fromEntries(this._virtualMocks), from, moduleName);\n\n      this._explicitShouldMock.set(moduleID, true);\n\n      return jestObject;\n    };\n\n    const setMockFactory = (moduleName, mockFactory, options) => {\n      this.setMock(from, moduleName, mockFactory, options);\n      return jestObject;\n    };\n\n    const clearAllMocks = () => {\n      this.clearAllMocks();\n      return jestObject;\n    };\n\n    const resetAllMocks = () => {\n      this.resetAllMocks();\n      return jestObject;\n    };\n\n    const restoreAllMocks = () => {\n      this.restoreAllMocks();\n      return jestObject;\n    };\n\n    const _getFakeTimers = () => {\n      if (!(this._environment.fakeTimers || this._environment.fakeTimersModern)) {\n        this._logFormattedReferenceError('You are trying to access a property or method of the Jest environment after it has been torn down.');\n\n        process.exitCode = 1;\n      }\n\n      return this._fakeTimersImplementation;\n    };\n\n    const useFakeTimers = (type = 'legacy') => {\n      if (type === 'modern') {\n        this._fakeTimersImplementation = this._environment.fakeTimersModern;\n      } else {\n        this._fakeTimersImplementation = this._environment.fakeTimers;\n      }\n\n      this._fakeTimersImplementation.useFakeTimers();\n\n      return jestObject;\n    };\n\n    const useRealTimers = () => {\n      _getFakeTimers().useRealTimers();\n\n      return jestObject;\n    };\n\n    const resetModules = () => {\n      this.resetModules();\n      return jestObject;\n    };\n\n    const isolateModules = fn => {\n      this.isolateModules(fn);\n      return jestObject;\n    };\n\n    const fn = this._moduleMocker.fn.bind(this._moduleMocker);\n\n    const spyOn = this._moduleMocker.spyOn.bind(this._moduleMocker);\n\n    const setTimeout = timeout => {\n      if (this._environment.global.jasmine) {\n        this._environment.global.jasmine._DEFAULT_TIMEOUT_INTERVAL = timeout;\n      } else {\n        // @ts-expect-error: https://github.com/Microsoft/TypeScript/issues/24587\n        this._environment.global[testTimeoutSymbol] = timeout;\n      }\n\n      return jestObject;\n    };\n\n    const retryTimes = numTestRetries => {\n      // @ts-expect-error: https://github.com/Microsoft/TypeScript/issues/24587\n      this._environment.global[retryTimesSymbol] = numTestRetries;\n      return jestObject;\n    };\n\n    const jestObject = {\n      addMatchers: matchers => this._environment.global.jasmine.addMatchers(matchers),\n      advanceTimersByTime: msToRun => _getFakeTimers().advanceTimersByTime(msToRun),\n      advanceTimersToNextTimer: steps => _getFakeTimers().advanceTimersToNextTimer(steps),\n      autoMockOff: disableAutomock,\n      autoMockOn: enableAutomock,\n      clearAllMocks,\n      clearAllTimers: () => _getFakeTimers().clearAllTimers(),\n      createMockFromModule: moduleName => this._generateMock(from, moduleName),\n      deepUnmock,\n      disableAutomock,\n      doMock: mock,\n      dontMock: unmock,\n      enableAutomock,\n      fn,\n      genMockFromModule: moduleName => this._generateMock(from, moduleName),\n      getRealSystemTime: () => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers instanceof _fakeTimers().ModernFakeTimers) {\n          return fakeTimers.getRealSystemTime();\n        } else {\n          throw new TypeError('getRealSystemTime is not available when not using modern timers');\n        }\n      },\n      getTimerCount: () => _getFakeTimers().getTimerCount(),\n      isMockFunction: this._moduleMocker.isMockFunction,\n      isolateModules,\n      mock,\n      requireActual: this.requireActual.bind(this, from),\n      requireMock: this.requireMock.bind(this, from),\n      resetAllMocks,\n      resetModuleRegistry: resetModules,\n      resetModules,\n      restoreAllMocks,\n      retryTimes,\n      runAllImmediates: () => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers instanceof _fakeTimers().LegacyFakeTimers) {\n          fakeTimers.runAllImmediates();\n        } else {\n          throw new TypeError('runAllImmediates is not available when using modern timers');\n        }\n      },\n      runAllTicks: () => _getFakeTimers().runAllTicks(),\n      runAllTimers: () => _getFakeTimers().runAllTimers(),\n      runOnlyPendingTimers: () => _getFakeTimers().runOnlyPendingTimers(),\n      runTimersToTime: msToRun => _getFakeTimers().advanceTimersByTime(msToRun),\n      setMock: (moduleName, mock) => setMockFactory(moduleName, () => mock),\n      setSystemTime: now => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers instanceof _fakeTimers().ModernFakeTimers) {\n          fakeTimers.setSystemTime(now);\n        } else {\n          throw new TypeError('setSystemTime is not available when not using modern timers');\n        }\n      },\n      setTimeout,\n      spyOn,\n      unmock,\n      useFakeTimers,\n      useRealTimers\n    };\n    return jestObject;\n  }\n\n  _logFormattedReferenceError(errorMessage) {\n    const originalStack = new ReferenceError(errorMessage).stack.split('\\n') // Remove this file from the stack (jest-message-utils will keep one line)\n    .filter(line => line.indexOf(__filename) === -1).join('\\n');\n    const {\n      message,\n      stack\n    } = (0, _jestMessageUtil().separateMessageFromStack)(originalStack);\n    console.error(`\\n${message}\\n` + (0, _jestMessageUtil().formatStackTrace)(stack, this._config, {\n      noStackTrace: false\n    }));\n  }\n\n  wrapCodeInModuleWrapper(content) {\n    return this.constructModuleWrapperStart() + content + '\\n}});';\n  }\n\n  constructModuleWrapperStart() {\n    const args = this.constructInjectedModuleParameters();\n    return '({\"' + EVAL_RESULT_VARIABLE + `\":function(${args.join(',')}){`;\n  }\n\n  constructInjectedModuleParameters() {\n    return ['module', 'exports', 'require', '__dirname', '__filename', 'global', this._config.injectGlobals ? 'jest' : undefined, ...this._config.extraGlobals].filter(notEmpty);\n  }\n\n  handleExecutionError(e, module) {\n    const moduleNotFoundError = _jestResolve().default.tryCastModuleNotFoundError(e);\n\n    if (moduleNotFoundError) {\n      if (!moduleNotFoundError.requireStack) {\n        moduleNotFoundError.requireStack = [module.filename || module.id];\n\n        for (let cursor = module.parent; cursor; cursor = cursor.parent) {\n          moduleNotFoundError.requireStack.push(cursor.filename || cursor.id);\n        }\n\n        moduleNotFoundError.buildMessage(this._config.rootDir);\n      }\n\n      throw moduleNotFoundError;\n    }\n\n    throw e;\n  }\n\n  getGlobalsForCjs(from) {\n    const jest = this.jestObjectCaches.get(from);\n    invariant(jest, 'There should always be a Jest object already');\n    return { ...this.getGlobalsFromEnvironment(),\n      jest\n    };\n  }\n\n  getGlobalsForEsm(from, context) {\n    let jest = this.jestObjectCaches.get(from);\n\n    if (!jest) {\n      jest = this._createJestObjectFor(from);\n      this.jestObjectCaches.set(from, jest);\n    }\n\n    const globals = { ...this.getGlobalsFromEnvironment(),\n      jest\n    };\n    const module = new (_vm().SyntheticModule)(Object.keys(globals), function () {\n      Object.entries(globals).forEach(([key, value]) => {\n        // @ts-expect-error: TS doesn't know what `this` is\n        this.setExport(key, value);\n      });\n    }, {\n      context,\n      identifier: '@jest/globals'\n    });\n    return evaluateSyntheticModule(module);\n  }\n\n  getGlobalsFromEnvironment() {\n    if (this.jestGlobals) {\n      return { ...this.jestGlobals\n      };\n    }\n\n    return {\n      afterAll: this._environment.global.afterAll,\n      afterEach: this._environment.global.afterEach,\n      beforeAll: this._environment.global.beforeAll,\n      beforeEach: this._environment.global.beforeEach,\n      describe: this._environment.global.describe,\n      expect: this._environment.global.expect,\n      fdescribe: this._environment.global.fdescribe,\n      fit: this._environment.global.fit,\n      it: this._environment.global.it,\n      test: this._environment.global.test,\n      xdescribe: this._environment.global.xdescribe,\n      xit: this._environment.global.xit,\n      xtest: this._environment.global.xtest\n    };\n  }\n\n  readFile(filename) {\n    let source = this._cacheFS.get(filename);\n\n    if (!source) {\n      source = fs().readFileSync(filename, 'utf8');\n\n      this._cacheFS.set(filename, source);\n    }\n\n    return source;\n  }\n\n  setGlobalsForRuntime(globals) {\n    this.jestGlobals = globals;\n  }\n\n}\n\n_defineProperty(Runtime, 'shouldInstrument', _transform().shouldInstrument);\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nfunction notEmpty(value) {\n  return value !== null && value !== undefined;\n}\n\nasync function evaluateSyntheticModule(module) {\n  await module.link(() => {\n    throw new Error('This should never happen');\n  });\n  await module.evaluate();\n  return module;\n}\n\nmodule.exports = Runtime;","map":{"version":3,"sources":["F:/GreenTea-Lemon/React/coderwhyReact/我的代码/15_learn_hooks/node_modules/jest-runtime/build/index.js"],"names":["nativeModule","data","_interopRequireWildcard","require","path","_url","_vm","_cjsModuleLexer","_collectV8Coverage","fs","_stripBom","_interopRequireDefault","_fakeTimers","_transform","_jestHasteMap","_jestMessageUtil","_jestMock","_jestRegexUtil","_jestResolve","_jestSnapshot","_jestUtil","_cli","_args","_helpers","_Object$fromEntries","obj","__esModule","default","_getRequireWildcardCache","WeakMap","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_defineProperty","value","enumerable","configurable","writable","esmIsAvailable","SourceTextModule","defaultTransformOptions","isInternalModule","supportsDynamicImport","supportsExportNamespaceFrom","supportsStaticESM","supportsTopLevelAwait","OUTSIDE_JEST_VM_RESOLVE_OPTION","Symbol","for","fromEntries","iterable","reduce","val","testTimeoutSymbol","retryTimesSymbol","NODE_MODULES","sep","getModuleNameMapper","config","Array","isArray","moduleNameMapper","length","map","regex","moduleName","RegExp","unmockRegExpCache","EVAL_RESULT_VARIABLE","runtimeSupportsVmModules","SyntheticModule","Runtime","constructor","environment","resolver","cacheFS","coverageOptions","testPath","unstable_shouldLoadAsEsm","_cacheFS","Map","entries","_config","_coverageOptions","changedFiles","undefined","collectCoverage","collectCoverageFrom","collectCoverageOnlyFrom","coverageProvider","sourcesRelatedToTestsInChangedFiles","_currentlyExecutingModulePath","_environment","_explicitShouldMock","_internalModuleRegistry","_isCurrentlyExecutingManualMock","_mainModule","_mockFactories","_mockRegistry","_moduleMocker","moduleMocker","_isolatedModuleRegistry","_isolatedMockRegistry","_moduleRegistry","_esmoduleRegistry","_testPath","_resolver","_scriptTransformer","ScriptTransformer","_shouldAutoMock","automock","_sourceMapRegistry","_fileTransforms","_virtualMocks","jestObjectCaches","_mockMetaDataCache","_shouldMockModuleCache","_shouldUnmockTransitiveDependenciesCache","_transitiveShouldMock","_fakeTimersImplementation","timers","fakeTimersModern","fakeTimers","_unmockList","unmockedModulePathPatterns","join","virtualMocks","setupFiles","forEach","filePath","includes","moduleID","getModuleID","resetModules","createContext","options","createDirectory","cacheDirectory","instance","createHasteMap","console","maxWorkers","resetCache","watch","watchman","build","then","hasteMap","hasteFS","moduleMap","createResolver","error","ignorePatternParts","modulePathIgnorePatterns","watchPathIgnorePatterns","startsWith","rootDir","filter","Boolean","ignorePattern","computeSha1","haste","dependencyExtractor","extensions","EXTENSION","concat","moduleFileExtensions","hasteImplModulePath","mocksPattern","escapePathForRegex","name","platforms","retainAllFiles","roots","throwOnModuleCollision","useWatchman","defaultPlatform","extension","hasCoreModules","moduleDirectories","modulePaths","runCLI","args","info","run","getCLIOptions","loadEsmModule","modulePath","query","cacheKey","invariant","getVmContext","context","isCoreModule","core","_importCoreModule","transformedCode","transformFile","module","identifier","importModuleDynamically","specifier","referencingModule","linkModules","initializeImportMeta","meta","url","pathToFileURL","href","link","evaluate","referencingIdentifier","fromCache","globals","getGlobalsForEsm","fileURLToPath","split","resolved","_resolveModule","loadCjsAsEsm","unstable_importModule","from","cjs","requireModuleOrMock","cjsExports","exports","parse","code","exportName","setExport","evaluateSyntheticModule","requireModule","isRequireActual","moduleResource","getModule","manualMock","getMockModule","_requireCoreModule","moduleRegistry","localModule","children","filename","id","loaded","dirname","_loadModule","requireInternalModule","to","outsideJestVmPath","decodePossibleOutsideJestVmPath","requireActual","requireMock","mockRegistry","manualMockOrStub","isManualMock","resolveStubModuleName","moduleDir","moduleFileName","basename","potentialManualMock","existsSync","_generateMock","extname","text","readFile","transformedFile","transformJson","_getFullTransformationOptions","global","JSON","fromPath","_execModule","getGlobalsForCjs","_shouldMock","e","moduleNotFound","tryCastModuleNotFoundError","siblingWithSimilarExtensionFound","hint","findSiblingsWithFileExtension","buildMessage","isolateModules","fn","Error","_this$_isolatedModule","_this$_isolatedMockRe","clear","_this$_isolatedModule2","_this$_isolatedMockRe2","envGlobal","keys","globalMock","_isMockFunction","mockClear","clearAllTimers","collectV8Coverage","_v8CoverageInstrumenter","CoverageInstrumenter","startInstrumenting","stopCollectingV8Coverage","_v8CoverageResult","stopInstrumenting","getAllCoverageInfoCopy","deepCyclicCopy","__coverage__","getAllV8CoverageInfoCopy","res","shouldInstrument","result","codeTransformResult","getSourceMapInfo","_coveredFiles","getSourceMaps","setMock","mockFactory","virtual","mockPath","getModulePath","restoreAllMocks","resetAllMocks","clearAllMocks","teardown","_moduleImplementation","resolveModule","_requireResolve","paths","p","absolutePath","resolve","resolveModuleFromDirIfExists","ModuleNotFoundError","err","_requireResolvePaths","getModulePaths","lastExecutingModulePath","origCurrExecutingManualMock","_createRequireImplementation","compiledFunction","script","createScriptFromCode","runScript","vmContext","runInContext","_logFormattedReferenceError","process","exitCode","jestObject","_createJestObjectFor","lastArgs","injectGlobals","extraGlobals","globalVariable","notEmpty","handleExecutionError","source","transform","wrapperLength","constructModuleWrapperStart","sourceMapPath","scriptSource","scriptFilename","Script","wrapCodeInModuleWrapper","displayErrors","_this$_environment$ge","_this$_environment","handlePotentialSyntaxError","_getMockedNativeModule","required","createRequire","URL","isAbsolute","TypeError","Module","createRequireFromPath","syncBuiltinESMExports","getMetadata","origMockRegistry","origModuleRegistry","moduleExports","mockMetadata","generateFromMetadata","explicitShouldMock","delimiter","test","currentModuleID","resolveOptions","createOutsideJestVmPath","moduleRequire","bind","create","notPermittedMethod","Proxy","deleteProperty","_target","ownKeys","disableAutomock","enableAutomock","unmock","deepUnmock","mock","setMockFactory","_getFakeTimers","useFakeTimers","type","useRealTimers","spyOn","setTimeout","timeout","jasmine","_DEFAULT_TIMEOUT_INTERVAL","retryTimes","numTestRetries","addMatchers","matchers","advanceTimersByTime","msToRun","advanceTimersToNextTimer","steps","autoMockOff","autoMockOn","createMockFromModule","doMock","dontMock","genMockFromModule","getRealSystemTime","ModernFakeTimers","getTimerCount","isMockFunction","resetModuleRegistry","runAllImmediates","LegacyFakeTimers","runAllTicks","runAllTimers","runOnlyPendingTimers","runTimersToTime","setSystemTime","now","errorMessage","originalStack","ReferenceError","stack","line","indexOf","__filename","message","separateMessageFromStack","formatStackTrace","noStackTrace","content","constructInjectedModuleParameters","moduleNotFoundError","requireStack","cursor","parent","push","jest","getGlobalsFromEnvironment","jestGlobals","afterAll","afterEach","beforeAll","beforeEach","describe","expect","fdescribe","fit","it","xdescribe","xit","xtest","readFileSync","setGlobalsForRuntime","condition"],"mappings":"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","sourcesContent":["'use strict';\n\nfunction nativeModule() {\n  const data = _interopRequireWildcard(require('module'));\n\n  nativeModule = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction path() {\n  const data = _interopRequireWildcard(require('path'));\n\n  path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _url() {\n  const data = require('url');\n\n  _url = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _vm() {\n  const data = require('vm');\n\n  _vm = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _cjsModuleLexer() {\n  const data = require('cjs-module-lexer');\n\n  _cjsModuleLexer = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _collectV8Coverage() {\n  const data = require('collect-v8-coverage');\n\n  _collectV8Coverage = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction fs() {\n  const data = _interopRequireWildcard(require('graceful-fs'));\n\n  fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _stripBom() {\n  const data = _interopRequireDefault(require('strip-bom'));\n\n  _stripBom = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _fakeTimers() {\n  const data = require('@jest/fake-timers');\n\n  _fakeTimers = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _transform() {\n  const data = require('@jest/transform');\n\n  _transform = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestHasteMap() {\n  const data = _interopRequireDefault(require('jest-haste-map'));\n\n  _jestHasteMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMessageUtil() {\n  const data = require('jest-message-util');\n\n  _jestMessageUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestMock() {\n  const data = _interopRequireDefault(require('jest-mock'));\n\n  _jestMock = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestRegexUtil() {\n  const data = require('jest-regex-util');\n\n  _jestRegexUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestResolve() {\n  const data = _interopRequireDefault(require('jest-resolve'));\n\n  _jestResolve = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestSnapshot() {\n  const data = _interopRequireDefault(require('jest-snapshot'));\n\n  _jestSnapshot = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _jestUtil() {\n  const data = require('jest-util');\n\n  _jestUtil = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _cli = require('./cli');\n\nvar _args = require('./cli/args');\n\nvar _helpers = require('./helpers');\n\nvar _Object$fromEntries;\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nconst esmIsAvailable = typeof _vm().SourceTextModule === 'function';\nconst defaultTransformOptions = {\n  isInternalModule: false,\n  supportsDynamicImport: esmIsAvailable,\n  supportsExportNamespaceFrom: false,\n  supportsStaticESM: false,\n  supportsTopLevelAwait: false\n};\nconst OUTSIDE_JEST_VM_RESOLVE_OPTION = Symbol.for(\n  'OUTSIDE_JEST_VM_RESOLVE_OPTION'\n);\nconst fromEntries =\n  (_Object$fromEntries = Object.fromEntries) !== null &&\n  _Object$fromEntries !== void 0\n    ? _Object$fromEntries\n    : function fromEntries(iterable) {\n        return [...iterable].reduce((obj, [key, val]) => {\n          obj[key] = val;\n          return obj;\n        }, {});\n      };\nconst testTimeoutSymbol = Symbol.for('TEST_TIMEOUT_SYMBOL');\nconst retryTimesSymbol = Symbol.for('RETRY_TIMES');\nconst NODE_MODULES = path().sep + 'node_modules' + path().sep;\n\nconst getModuleNameMapper = config => {\n  if (\n    Array.isArray(config.moduleNameMapper) &&\n    config.moduleNameMapper.length\n  ) {\n    return config.moduleNameMapper.map(([regex, moduleName]) => ({\n      moduleName,\n      regex: new RegExp(regex)\n    }));\n  }\n\n  return null;\n};\n\nconst unmockRegExpCache = new WeakMap();\nconst EVAL_RESULT_VARIABLE = 'Object.<anonymous>';\nconst runtimeSupportsVmModules = typeof _vm().SyntheticModule === 'function';\n\nconst supportsTopLevelAwait =\n  runtimeSupportsVmModules &&\n  (() => {\n    try {\n      // eslint-disable-next-line no-new\n      new (_vm().SourceTextModule)('await Promise.resolve()');\n      return true;\n    } catch {\n      return false;\n    }\n  })();\n\nclass Runtime {\n  constructor(\n    config,\n    environment,\n    resolver,\n    cacheFS = {},\n    coverageOptions, // TODO: Make mandatory in Jest 27\n    testPath\n  ) {\n    _defineProperty(this, '_cacheFS', void 0);\n\n    _defineProperty(this, '_config', void 0);\n\n    _defineProperty(this, '_coverageOptions', void 0);\n\n    _defineProperty(this, '_currentlyExecutingModulePath', void 0);\n\n    _defineProperty(this, '_environment', void 0);\n\n    _defineProperty(this, '_explicitShouldMock', void 0);\n\n    _defineProperty(this, '_fakeTimersImplementation', void 0);\n\n    _defineProperty(this, '_internalModuleRegistry', void 0);\n\n    _defineProperty(this, '_isCurrentlyExecutingManualMock', void 0);\n\n    _defineProperty(this, '_mainModule', void 0);\n\n    _defineProperty(this, '_mockFactories', void 0);\n\n    _defineProperty(this, '_mockMetaDataCache', void 0);\n\n    _defineProperty(this, '_mockRegistry', void 0);\n\n    _defineProperty(this, '_isolatedMockRegistry', void 0);\n\n    _defineProperty(this, '_moduleMocker', void 0);\n\n    _defineProperty(this, '_isolatedModuleRegistry', void 0);\n\n    _defineProperty(this, '_moduleRegistry', void 0);\n\n    _defineProperty(this, '_esmoduleRegistry', void 0);\n\n    _defineProperty(this, '_testPath', void 0);\n\n    _defineProperty(this, '_resolver', void 0);\n\n    _defineProperty(this, '_shouldAutoMock', void 0);\n\n    _defineProperty(this, '_shouldMockModuleCache', void 0);\n\n    _defineProperty(this, '_shouldUnmockTransitiveDependenciesCache', void 0);\n\n    _defineProperty(this, '_sourceMapRegistry', void 0);\n\n    _defineProperty(this, '_scriptTransformer', void 0);\n\n    _defineProperty(this, '_fileTransforms', void 0);\n\n    _defineProperty(this, '_v8CoverageInstrumenter', void 0);\n\n    _defineProperty(this, '_v8CoverageResult', void 0);\n\n    _defineProperty(this, '_transitiveShouldMock', void 0);\n\n    _defineProperty(this, '_unmockList', void 0);\n\n    _defineProperty(this, '_virtualMocks', void 0);\n\n    _defineProperty(this, '_moduleImplementation', void 0);\n\n    _defineProperty(this, 'jestObjectCaches', void 0);\n\n    _defineProperty(this, 'jestGlobals', void 0);\n\n    _defineProperty(\n      this,\n      'unstable_shouldLoadAsEsm',\n      _jestResolve().default.unstable_shouldLoadAsEsm\n    );\n\n    this._cacheFS = new Map(Object.entries(cacheFS));\n    this._config = config;\n    this._coverageOptions = coverageOptions || {\n      changedFiles: undefined,\n      collectCoverage: false,\n      collectCoverageFrom: [],\n      collectCoverageOnlyFrom: undefined,\n      coverageProvider: 'babel',\n      sourcesRelatedToTestsInChangedFiles: undefined\n    };\n    this._currentlyExecutingModulePath = '';\n    this._environment = environment;\n    this._explicitShouldMock = new Map();\n    this._internalModuleRegistry = new Map();\n    this._isCurrentlyExecutingManualMock = null;\n    this._mainModule = null;\n    this._mockFactories = new Map();\n    this._mockRegistry = new Map(); // during setup, this cannot be null (and it's fine to explode if it is)\n\n    this._moduleMocker = this._environment.moduleMocker;\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n    this._moduleRegistry = new Map();\n    this._esmoduleRegistry = new Map();\n    this._testPath = testPath;\n    this._resolver = resolver;\n    this._scriptTransformer = new (_transform().ScriptTransformer)(config);\n    this._shouldAutoMock = config.automock;\n    this._sourceMapRegistry = new Map();\n    this._fileTransforms = new Map();\n    this._virtualMocks = new Map();\n    this.jestObjectCaches = new Map();\n    this._mockMetaDataCache = new Map();\n    this._shouldMockModuleCache = new Map();\n    this._shouldUnmockTransitiveDependenciesCache = new Map();\n    this._transitiveShouldMock = new Map();\n    this._fakeTimersImplementation =\n      config.timers === 'modern'\n        ? this._environment.fakeTimersModern\n        : this._environment.fakeTimers;\n    this._unmockList = unmockRegExpCache.get(config);\n\n    if (!this._unmockList && config.unmockedModulePathPatterns) {\n      this._unmockList = new RegExp(\n        config.unmockedModulePathPatterns.join('|')\n      );\n      unmockRegExpCache.set(config, this._unmockList);\n    }\n\n    if (config.automock) {\n      const virtualMocks = fromEntries(this._virtualMocks);\n      config.setupFiles.forEach(filePath => {\n        if (filePath && filePath.includes(NODE_MODULES)) {\n          const moduleID = this._resolver.getModuleID(virtualMocks, filePath);\n\n          this._transitiveShouldMock.set(moduleID, false);\n        }\n      });\n    }\n\n    this.resetModules();\n  }\n\n  static createContext(config, options) {\n    (0, _jestUtil().createDirectory)(config.cacheDirectory);\n    const instance = Runtime.createHasteMap(config, {\n      console: options.console,\n      maxWorkers: options.maxWorkers,\n      resetCache: !config.cache,\n      watch: options.watch,\n      watchman: options.watchman\n    });\n    return instance.build().then(\n      hasteMap => ({\n        config,\n        hasteFS: hasteMap.hasteFS,\n        moduleMap: hasteMap.moduleMap,\n        resolver: Runtime.createResolver(config, hasteMap.moduleMap)\n      }),\n      error => {\n        throw error;\n      }\n    );\n  }\n\n  static createHasteMap(config, options) {\n    const ignorePatternParts = [\n      ...config.modulePathIgnorePatterns,\n      ...(options && options.watch ? config.watchPathIgnorePatterns : []),\n      config.cacheDirectory.startsWith(config.rootDir + path().sep) &&\n        config.cacheDirectory\n    ].filter(Boolean);\n    const ignorePattern =\n      ignorePatternParts.length > 0\n        ? new RegExp(ignorePatternParts.join('|'))\n        : undefined;\n    return new (_jestHasteMap().default)({\n      cacheDirectory: config.cacheDirectory,\n      computeSha1: config.haste.computeSha1,\n      console: options && options.console,\n      dependencyExtractor: config.dependencyExtractor,\n      extensions: [_jestSnapshot().default.EXTENSION].concat(\n        config.moduleFileExtensions\n      ),\n      hasteImplModulePath: config.haste.hasteImplModulePath,\n      ignorePattern,\n      maxWorkers: (options && options.maxWorkers) || 1,\n      mocksPattern: (0, _jestRegexUtil().escapePathForRegex)(\n        path().sep + '__mocks__' + path().sep\n      ),\n      name: config.name,\n      platforms: config.haste.platforms || ['ios', 'android'],\n      resetCache: options && options.resetCache,\n      retainAllFiles: false,\n      rootDir: config.rootDir,\n      roots: config.roots,\n      throwOnModuleCollision: config.haste.throwOnModuleCollision,\n      useWatchman: options && options.watchman,\n      watch: options && options.watch\n    });\n  }\n\n  static createResolver(config, moduleMap) {\n    return new (_jestResolve().default)(moduleMap, {\n      defaultPlatform: config.haste.defaultPlatform,\n      extensions: config.moduleFileExtensions.map(extension => '.' + extension),\n      hasCoreModules: true,\n      moduleDirectories: config.moduleDirectories,\n      moduleNameMapper: getModuleNameMapper(config),\n      modulePaths: config.modulePaths,\n      platforms: config.haste.platforms,\n      resolver: config.resolver,\n      rootDir: config.rootDir\n    });\n  }\n\n  static runCLI(args, info) {\n    return (0, _cli.run)(args, info);\n  }\n\n  static getCLIOptions() {\n    return _args.options;\n  } // unstable as it should be replaced by https://github.com/nodejs/modules/issues/393, and we don't want people to use it\n\n  async loadEsmModule(modulePath, query = '') {\n    const cacheKey = modulePath + query;\n\n    if (!this._esmoduleRegistry.has(cacheKey)) {\n      invariant(\n        typeof this._environment.getVmContext === 'function',\n        'ES Modules are only supported if your test environment has the `getVmContext` function'\n      );\n\n      const context = this._environment.getVmContext();\n\n      invariant(context);\n\n      if (this._resolver.isCoreModule(modulePath)) {\n        const core = await this._importCoreModule(modulePath, context);\n\n        this._esmoduleRegistry.set(cacheKey, core);\n\n        return core;\n      }\n\n      const transformedCode = this.transformFile(modulePath, {\n        isInternalModule: false,\n        supportsDynamicImport: true,\n        supportsExportNamespaceFrom: true,\n        supportsStaticESM: true,\n        supportsTopLevelAwait\n      });\n      const module = new (_vm().SourceTextModule)(transformedCode, {\n        context,\n        identifier: modulePath,\n        importModuleDynamically: (specifier, referencingModule) =>\n          this.linkModules(\n            specifier,\n            referencingModule.identifier,\n            referencingModule.context\n          ),\n\n        initializeImportMeta(meta) {\n          meta.url = (0, _url().pathToFileURL)(modulePath).href;\n        }\n      });\n\n      this._esmoduleRegistry.set(\n        cacheKey, // we wanna put the linking promise in the cache so modules loaded in\n        // parallel can all await it. We then await it synchronously below, so\n        // we shouldn't get any unhandled rejections\n        module\n          .link((specifier, referencingModule) =>\n            this.linkModules(\n              specifier,\n              referencingModule.identifier,\n              referencingModule.context\n            )\n          )\n          .then(() => module.evaluate())\n          .then(() => module)\n      );\n    }\n\n    const module = this._esmoduleRegistry.get(cacheKey);\n\n    invariant(module);\n    return module;\n  }\n\n  linkModules(specifier, referencingIdentifier, context) {\n    if (specifier === '@jest/globals') {\n      const fromCache = this._esmoduleRegistry.get('@jest/globals');\n\n      if (fromCache) {\n        return fromCache;\n      }\n\n      const globals = this.getGlobalsForEsm(referencingIdentifier, context);\n\n      this._esmoduleRegistry.set('@jest/globals', globals);\n\n      return globals;\n    }\n\n    if (specifier.startsWith('file://')) {\n      specifier = (0, _url().fileURLToPath)(specifier);\n    }\n\n    const [path, query] = specifier.split('?');\n\n    const resolved = this._resolveModule(referencingIdentifier, path);\n\n    if (\n      this._resolver.isCoreModule(resolved) ||\n      this.unstable_shouldLoadAsEsm(resolved)\n    ) {\n      return this.loadEsmModule(resolved, query);\n    }\n\n    return this.loadCjsAsEsm(referencingIdentifier, resolved, context);\n  }\n\n  async unstable_importModule(from, moduleName) {\n    invariant(\n      runtimeSupportsVmModules,\n      'You need to run with a version of node that supports ES Modules in the VM API.'\n    );\n    const [path, query] = (moduleName !== null && moduleName !== void 0\n      ? moduleName\n      : ''\n    ).split('?');\n\n    const modulePath = this._resolveModule(from, path);\n\n    return this.loadEsmModule(modulePath, query);\n  }\n\n  loadCjsAsEsm(from, modulePath, context) {\n    // CJS loaded via `import` should share cache with other CJS: https://github.com/nodejs/modules/issues/503\n    const cjs = this.requireModuleOrMock(from, modulePath);\n\n    const transformedCode = this._fileTransforms.get(modulePath);\n\n    let cjsExports = [];\n\n    if (transformedCode) {\n      const {exports} = (0, _cjsModuleLexer().parse)(transformedCode.code);\n      cjsExports = exports.filter(exportName => {\n        // we don't wanna respect any exports _names_ default as a named export\n        if (exportName === 'default') {\n          return false;\n        }\n\n        return Object.hasOwnProperty.call(cjs, exportName);\n      });\n    }\n\n    const module = new (_vm().SyntheticModule)(\n      [...cjsExports, 'default'],\n      function () {\n        cjsExports.forEach(exportName => {\n          // @ts-expect-error\n          this.setExport(exportName, cjs[exportName]);\n        }); // @ts-expect-error: TS doesn't know what `this` is\n\n        this.setExport('default', cjs);\n      },\n      {\n        context,\n        identifier: modulePath\n      }\n    );\n    return evaluateSyntheticModule(module);\n  }\n\n  requireModule(from, moduleName, options, isRequireActual) {\n    const moduleID = this._resolver.getModuleID(\n      fromEntries(this._virtualMocks),\n      from,\n      moduleName\n    );\n\n    let modulePath; // Some old tests rely on this mocking behavior. Ideally we'll change this\n    // to be more explicit.\n\n    const moduleResource = moduleName && this._resolver.getModule(moduleName);\n\n    const manualMock =\n      moduleName && this._resolver.getMockModule(from, moduleName);\n\n    if (\n      !(options === null || options === void 0\n        ? void 0\n        : options.isInternalModule) &&\n      !isRequireActual &&\n      !moduleResource &&\n      manualMock &&\n      manualMock !== this._isCurrentlyExecutingManualMock &&\n      this._explicitShouldMock.get(moduleID) !== false\n    ) {\n      modulePath = manualMock;\n    }\n\n    if (moduleName && this._resolver.isCoreModule(moduleName)) {\n      return this._requireCoreModule(moduleName);\n    }\n\n    if (!modulePath) {\n      modulePath = this._resolveModule(from, moduleName);\n    }\n\n    let moduleRegistry;\n\n    if (\n      options === null || options === void 0 ? void 0 : options.isInternalModule\n    ) {\n      moduleRegistry = this._internalModuleRegistry;\n    } else {\n      if (\n        this._moduleRegistry.get(modulePath) ||\n        !this._isolatedModuleRegistry\n      ) {\n        moduleRegistry = this._moduleRegistry;\n      } else {\n        moduleRegistry = this._isolatedModuleRegistry;\n      }\n    }\n\n    const module = moduleRegistry.get(modulePath);\n\n    if (module) {\n      return module.exports;\n    } // We must register the pre-allocated module object first so that any\n    // circular dependencies that may arise while evaluating the module can\n    // be satisfied.\n\n    const localModule = {\n      children: [],\n      exports: {},\n      filename: modulePath,\n      id: modulePath,\n      loaded: false,\n      path: path().dirname(modulePath)\n    };\n    moduleRegistry.set(modulePath, localModule);\n\n    this._loadModule(\n      localModule,\n      from,\n      moduleName,\n      modulePath,\n      options,\n      moduleRegistry\n    );\n\n    return localModule.exports;\n  }\n\n  requireInternalModule(from, to) {\n    if (to) {\n      const outsideJestVmPath = (0, _helpers.decodePossibleOutsideJestVmPath)(\n        to\n      );\n\n      if (outsideJestVmPath) {\n        return require(outsideJestVmPath);\n      }\n    }\n\n    return this.requireModule(from, to, {\n      isInternalModule: true,\n      supportsDynamicImport: esmIsAvailable,\n      supportsExportNamespaceFrom: false,\n      supportsStaticESM: false,\n      supportsTopLevelAwait: false\n    });\n  }\n\n  requireActual(from, moduleName) {\n    return this.requireModule(from, moduleName, undefined, true);\n  }\n\n  requireMock(from, moduleName) {\n    const moduleID = this._resolver.getModuleID(\n      fromEntries(this._virtualMocks),\n      from,\n      moduleName\n    );\n\n    if (\n      this._isolatedMockRegistry &&\n      this._isolatedMockRegistry.get(moduleID)\n    ) {\n      return this._isolatedMockRegistry.get(moduleID);\n    } else if (this._mockRegistry.get(moduleID)) {\n      return this._mockRegistry.get(moduleID);\n    }\n\n    const mockRegistry = this._isolatedMockRegistry || this._mockRegistry;\n\n    if (this._mockFactories.has(moduleID)) {\n      // has check above makes this ok\n      const module = this._mockFactories.get(moduleID)();\n\n      mockRegistry.set(moduleID, module);\n      return module;\n    }\n\n    const manualMockOrStub = this._resolver.getMockModule(from, moduleName);\n\n    let modulePath =\n      this._resolver.getMockModule(from, moduleName) ||\n      this._resolveModule(from, moduleName);\n\n    let isManualMock =\n      manualMockOrStub &&\n      !this._resolver.resolveStubModuleName(from, moduleName);\n\n    if (!isManualMock) {\n      // If the actual module file has a __mocks__ dir sitting immediately next\n      // to it, look to see if there is a manual mock for this file.\n      //\n      // subDir1/my_module.js\n      // subDir1/__mocks__/my_module.js\n      // subDir2/my_module.js\n      // subDir2/__mocks__/my_module.js\n      //\n      // Where some other module does a relative require into each of the\n      // respective subDir{1,2} directories and expects a manual mock\n      // corresponding to that particular my_module.js file.\n      const moduleDir = path().dirname(modulePath);\n      const moduleFileName = path().basename(modulePath);\n      const potentialManualMock = path().join(\n        moduleDir,\n        '__mocks__',\n        moduleFileName\n      );\n\n      if (fs().existsSync(potentialManualMock)) {\n        isManualMock = true;\n        modulePath = potentialManualMock;\n      }\n    }\n\n    if (isManualMock) {\n      const localModule = {\n        children: [],\n        exports: {},\n        filename: modulePath,\n        id: modulePath,\n        loaded: false,\n        path: path().dirname(modulePath)\n      };\n\n      this._loadModule(\n        localModule,\n        from,\n        moduleName,\n        modulePath,\n        undefined,\n        mockRegistry\n      );\n\n      mockRegistry.set(moduleID, localModule.exports);\n    } else {\n      // Look for a real module to generate an automock from\n      mockRegistry.set(moduleID, this._generateMock(from, moduleName));\n    }\n\n    return mockRegistry.get(moduleID);\n  }\n\n  _loadModule(\n    localModule,\n    from,\n    moduleName,\n    modulePath,\n    options,\n    moduleRegistry\n  ) {\n    if (path().extname(modulePath) === '.json') {\n      const text = (0, _stripBom().default)(this.readFile(modulePath));\n\n      const transformedFile = this._scriptTransformer.transformJson(\n        modulePath,\n        this._getFullTransformationOptions(options),\n        text\n      );\n\n      localModule.exports = this._environment.global.JSON.parse(\n        transformedFile\n      );\n    } else if (path().extname(modulePath) === '.node') {\n      localModule.exports = require(modulePath);\n    } else {\n      // Only include the fromPath if a moduleName is given. Else treat as root.\n      const fromPath = moduleName ? from : null;\n\n      this._execModule(localModule, options, moduleRegistry, fromPath);\n    }\n\n    localModule.loaded = true;\n  }\n\n  _getFullTransformationOptions(options = defaultTransformOptions) {\n    return {...options, ...this._coverageOptions};\n  }\n\n  requireModuleOrMock(from, moduleName) {\n    // this module is unmockable\n    if (moduleName === '@jest/globals') {\n      // @ts-expect-error: we don't care that it's not assignable to T\n      return this.getGlobalsForCjs(from);\n    }\n\n    try {\n      if (this._shouldMock(from, moduleName)) {\n        return this.requireMock(from, moduleName);\n      } else {\n        return this.requireModule(from, moduleName);\n      }\n    } catch (e) {\n      const moduleNotFound = _jestResolve().default.tryCastModuleNotFoundError(\n        e\n      );\n\n      if (moduleNotFound) {\n        if (\n          moduleNotFound.siblingWithSimilarExtensionFound === null ||\n          moduleNotFound.siblingWithSimilarExtensionFound === undefined\n        ) {\n          moduleNotFound.hint = (0, _helpers.findSiblingsWithFileExtension)(\n            this._config.moduleFileExtensions,\n            from,\n            moduleNotFound.moduleName || moduleName\n          );\n          moduleNotFound.siblingWithSimilarExtensionFound = Boolean(\n            moduleNotFound.hint\n          );\n        }\n\n        moduleNotFound.buildMessage(this._config.rootDir);\n        throw moduleNotFound;\n      }\n\n      throw e;\n    }\n  }\n\n  isolateModules(fn) {\n    if (this._isolatedModuleRegistry || this._isolatedMockRegistry) {\n      throw new Error(\n        'isolateModules cannot be nested inside another isolateModules.'\n      );\n    }\n\n    this._isolatedModuleRegistry = new Map();\n    this._isolatedMockRegistry = new Map();\n\n    try {\n      fn();\n    } finally {\n      var _this$_isolatedModule, _this$_isolatedMockRe;\n\n      // might be cleared within the callback\n      (_this$_isolatedModule = this._isolatedModuleRegistry) === null ||\n      _this$_isolatedModule === void 0\n        ? void 0\n        : _this$_isolatedModule.clear();\n      (_this$_isolatedMockRe = this._isolatedMockRegistry) === null ||\n      _this$_isolatedMockRe === void 0\n        ? void 0\n        : _this$_isolatedMockRe.clear();\n      this._isolatedModuleRegistry = null;\n      this._isolatedMockRegistry = null;\n    }\n  }\n\n  resetModules() {\n    var _this$_isolatedModule2, _this$_isolatedMockRe2;\n\n    (_this$_isolatedModule2 = this._isolatedModuleRegistry) === null ||\n    _this$_isolatedModule2 === void 0\n      ? void 0\n      : _this$_isolatedModule2.clear();\n    (_this$_isolatedMockRe2 = this._isolatedMockRegistry) === null ||\n    _this$_isolatedMockRe2 === void 0\n      ? void 0\n      : _this$_isolatedMockRe2.clear();\n    this._isolatedModuleRegistry = null;\n    this._isolatedMockRegistry = null;\n\n    this._mockRegistry.clear();\n\n    this._moduleRegistry.clear();\n\n    this._esmoduleRegistry.clear();\n\n    if (this._environment) {\n      if (this._environment.global) {\n        const envGlobal = this._environment.global;\n        Object.keys(envGlobal).forEach(key => {\n          const globalMock = envGlobal[key];\n\n          if (\n            ((typeof globalMock === 'object' && globalMock !== null) ||\n              typeof globalMock === 'function') &&\n            globalMock._isMockFunction === true\n          ) {\n            globalMock.mockClear();\n          }\n        });\n      }\n\n      if (this._environment.fakeTimers) {\n        this._environment.fakeTimers.clearAllTimers();\n      }\n    }\n  }\n\n  async collectV8Coverage() {\n    this._v8CoverageInstrumenter = new (_collectV8Coverage().CoverageInstrumenter)();\n    await this._v8CoverageInstrumenter.startInstrumenting();\n  }\n\n  async stopCollectingV8Coverage() {\n    if (!this._v8CoverageInstrumenter) {\n      throw new Error('You need to call `collectV8Coverage` first.');\n    }\n\n    this._v8CoverageResult = await this._v8CoverageInstrumenter.stopInstrumenting();\n  }\n\n  getAllCoverageInfoCopy() {\n    return (0, _jestUtil().deepCyclicCopy)(\n      this._environment.global.__coverage__\n    );\n  }\n\n  getAllV8CoverageInfoCopy() {\n    if (!this._v8CoverageResult) {\n      throw new Error('You need to `stopCollectingV8Coverage` first');\n    }\n\n    return this._v8CoverageResult\n      .filter(res => res.url.startsWith('file://'))\n      .map(res => ({...res, url: (0, _url().fileURLToPath)(res.url)}))\n      .filter(\n        (\n          res // TODO: will this work on windows? It might be better if `shouldInstrument` deals with it anyways\n        ) =>\n          res.url.startsWith(this._config.rootDir) &&\n          this._fileTransforms.has(res.url) &&\n          (0, _transform().shouldInstrument)(\n            res.url,\n            this._coverageOptions,\n            this._config\n          )\n      )\n      .map(result => {\n        const transformedFile = this._fileTransforms.get(result.url);\n\n        return {\n          codeTransformResult: transformedFile,\n          result\n        };\n      });\n  } // TODO - remove in Jest 27\n\n  getSourceMapInfo(_coveredFiles) {\n    return {};\n  }\n\n  getSourceMaps() {\n    return fromEntries(this._sourceMapRegistry);\n  }\n\n  setMock(from, moduleName, mockFactory, options) {\n    if (options === null || options === void 0 ? void 0 : options.virtual) {\n      const mockPath = this._resolver.getModulePath(from, moduleName);\n\n      this._virtualMocks.set(mockPath, true);\n    }\n\n    const moduleID = this._resolver.getModuleID(\n      fromEntries(this._virtualMocks),\n      from,\n      moduleName\n    );\n\n    this._explicitShouldMock.set(moduleID, true);\n\n    this._mockFactories.set(moduleID, mockFactory);\n  }\n\n  restoreAllMocks() {\n    this._moduleMocker.restoreAllMocks();\n  }\n\n  resetAllMocks() {\n    this._moduleMocker.resetAllMocks();\n  }\n\n  clearAllMocks() {\n    this._moduleMocker.clearAllMocks();\n  }\n\n  teardown() {\n    this.restoreAllMocks();\n    this.resetAllMocks();\n    this.resetModules();\n\n    this._internalModuleRegistry.clear();\n\n    this._mainModule = null;\n\n    this._mockFactories.clear();\n\n    this._mockMetaDataCache.clear();\n\n    this._shouldMockModuleCache.clear();\n\n    this._shouldUnmockTransitiveDependenciesCache.clear();\n\n    this._explicitShouldMock.clear();\n\n    this._transitiveShouldMock.clear();\n\n    this._virtualMocks.clear();\n\n    this._cacheFS.clear();\n\n    this._unmockList = undefined;\n\n    this._sourceMapRegistry.clear();\n\n    this._fileTransforms.clear();\n\n    this.jestObjectCaches.clear();\n    this._v8CoverageResult = [];\n    this._v8CoverageInstrumenter = undefined;\n    this._moduleImplementation = undefined;\n  }\n\n  _resolveModule(from, to) {\n    return to ? this._resolver.resolveModule(from, to) : from;\n  }\n\n  _requireResolve(from, moduleName, options = {}) {\n    if (moduleName == null) {\n      throw new Error(\n        'The first argument to require.resolve must be a string. Received null or undefined.'\n      );\n    }\n\n    const {paths} = options;\n\n    if (paths) {\n      for (const p of paths) {\n        const absolutePath = path().resolve(from, '..', p);\n\n        const module = this._resolver.resolveModuleFromDirIfExists(\n          absolutePath,\n          moduleName, // required to also resolve files without leading './' directly in the path\n          {\n            paths: [absolutePath]\n          }\n        );\n\n        if (module) {\n          return module;\n        }\n      }\n\n      throw new (_jestResolve().default.ModuleNotFoundError)(\n        `Cannot resolve module '${moduleName}' from paths ['${paths.join(\n          \"', '\"\n        )}'] from ${from}`\n      );\n    }\n\n    try {\n      return this._resolveModule(from, moduleName);\n    } catch (err) {\n      const module = this._resolver.getMockModule(from, moduleName);\n\n      if (module) {\n        return module;\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  _requireResolvePaths(from, moduleName) {\n    if (moduleName == null) {\n      throw new Error(\n        'The first argument to require.resolve.paths must be a string. Received null or undefined.'\n      );\n    }\n\n    if (!moduleName.length) {\n      throw new Error(\n        'The first argument to require.resolve.paths must not be the empty string.'\n      );\n    }\n\n    if (moduleName[0] === '.') {\n      return [path().resolve(from, '..')];\n    }\n\n    if (this._resolver.isCoreModule(moduleName)) {\n      return null;\n    }\n\n    return this._resolver.getModulePaths(path().resolve(from, '..'));\n  }\n\n  _execModule(localModule, options, moduleRegistry, from) {\n    // If the environment was disposed, prevent this module from being executed.\n    if (!this._environment.global) {\n      return;\n    }\n\n    const module = localModule;\n    const filename = module.filename;\n    const lastExecutingModulePath = this._currentlyExecutingModulePath;\n    this._currentlyExecutingModulePath = filename;\n    const origCurrExecutingManualMock = this._isCurrentlyExecutingManualMock;\n    this._isCurrentlyExecutingManualMock = filename;\n    module.children = [];\n    Object.defineProperty(module, 'parent', {\n      enumerable: true,\n\n      get() {\n        const key = from || '';\n        return moduleRegistry.get(key) || null;\n      }\n    });\n    module.paths = this._resolver.getModulePaths(module.path);\n    Object.defineProperty(module, 'require', {\n      value: this._createRequireImplementation(module, options)\n    });\n    const transformedCode = this.transformFile(filename, options);\n    let compiledFunction = null;\n    const script = this.createScriptFromCode(transformedCode, filename);\n    let runScript = null; // Use this if available instead of deprecated `JestEnvironment.runScript`\n\n    if (typeof this._environment.getVmContext === 'function') {\n      const vmContext = this._environment.getVmContext();\n\n      if (vmContext) {\n        runScript = script.runInContext(vmContext, {\n          filename\n        });\n      }\n    } else {\n      runScript = this._environment.runScript(script);\n    }\n\n    if (runScript !== null) {\n      compiledFunction = runScript[EVAL_RESULT_VARIABLE];\n    }\n\n    if (compiledFunction === null) {\n      this._logFormattedReferenceError(\n        'You are trying to `import` a file after the Jest environment has been torn down.'\n      );\n\n      process.exitCode = 1;\n      return;\n    }\n\n    const jestObject = this._createJestObjectFor(filename);\n\n    this.jestObjectCaches.set(filename, jestObject);\n    const lastArgs = [\n      this._config.injectGlobals ? jestObject : undefined, // jest object\n      ...this._config.extraGlobals.map(globalVariable => {\n        if (this._environment.global[globalVariable]) {\n          return this._environment.global[globalVariable];\n        }\n\n        throw new Error(\n          `You have requested '${globalVariable}' as a global variable, but it was not present. Please check your config or your global environment.`\n        );\n      })\n    ];\n\n    if (!this._mainModule && filename === this._testPath) {\n      this._mainModule = module;\n    }\n\n    Object.defineProperty(module, 'main', {\n      enumerable: true,\n      value: this._mainModule\n    });\n\n    try {\n      compiledFunction.call(\n        module.exports,\n        module, // module object\n        module.exports, // module exports\n        module.require, // require implementation\n        module.path, // __dirname\n        module.filename, // __filename\n        this._environment.global, // global object\n        // @ts-expect-error\n        ...lastArgs.filter(notEmpty)\n      );\n    } catch (error) {\n      this.handleExecutionError(error, module);\n    }\n\n    this._isCurrentlyExecutingManualMock = origCurrExecutingManualMock;\n    this._currentlyExecutingModulePath = lastExecutingModulePath;\n  }\n\n  transformFile(filename, options) {\n    const source = this.readFile(filename);\n\n    if (\n      options === null || options === void 0 ? void 0 : options.isInternalModule\n    ) {\n      return source;\n    }\n\n    const transformedFile = this._scriptTransformer.transform(\n      filename,\n      this._getFullTransformationOptions(options),\n      source\n    );\n\n    this._fileTransforms.set(filename, {\n      ...transformedFile,\n      wrapperLength: this.constructModuleWrapperStart().length\n    });\n\n    if (transformedFile.sourceMapPath) {\n      this._sourceMapRegistry.set(filename, transformedFile.sourceMapPath);\n    }\n\n    return transformedFile.code;\n  }\n\n  createScriptFromCode(scriptSource, filename) {\n    try {\n      const scriptFilename = this._resolver.isCoreModule(filename)\n        ? `jest-nodejs-core-${filename}`\n        : filename;\n      return new (_vm().Script)(this.wrapCodeInModuleWrapper(scriptSource), {\n        displayErrors: true,\n        filename: scriptFilename,\n        // @ts-expect-error: Experimental ESM API\n        importModuleDynamically: specifier => {\n          var _this$_environment$ge, _this$_environment;\n\n          const context =\n            (_this$_environment$ge = (_this$_environment = this._environment)\n              .getVmContext) === null || _this$_environment$ge === void 0\n              ? void 0\n              : _this$_environment$ge.call(_this$_environment);\n          invariant(context);\n          return this.linkModules(specifier, scriptFilename, context);\n        }\n      });\n    } catch (e) {\n      throw (0, _transform().handlePotentialSyntaxError)(e);\n    }\n  }\n\n  _requireCoreModule(moduleName) {\n    if (moduleName === 'process') {\n      return this._environment.global.process;\n    }\n\n    if (moduleName === 'module') {\n      return this._getMockedNativeModule();\n    }\n\n    return require(moduleName);\n  }\n\n  _importCoreModule(moduleName, context) {\n    const required = this._requireCoreModule(moduleName);\n\n    const module = new (_vm().SyntheticModule)(\n      ['default', ...Object.keys(required)],\n      function () {\n        // @ts-expect-error: TS doesn't know what `this` is\n        this.setExport('default', required);\n        Object.entries(required).forEach(([key, value]) => {\n          // @ts-expect-error: TS doesn't know what `this` is\n          this.setExport(key, value);\n        });\n      }, // should identifier be `node://${moduleName}`?\n      {\n        context,\n        identifier: moduleName\n      }\n    );\n    return evaluateSyntheticModule(module);\n  }\n\n  _getMockedNativeModule() {\n    if (this._moduleImplementation) {\n      return this._moduleImplementation;\n    }\n\n    const createRequire = modulePath => {\n      const filename =\n        typeof modulePath === 'string'\n          ? modulePath.startsWith('file:///')\n            ? (0, _url().fileURLToPath)(new (_url().URL)(modulePath))\n            : modulePath\n          : (0, _url().fileURLToPath)(modulePath);\n\n      if (!path().isAbsolute(filename)) {\n        const error = new TypeError(\n          `The argument 'filename' must be a file URL object, file URL string, or absolute path string. Received '${filename}'`\n        ); // @ts-expect-error\n\n        error.code = 'ERR_INVALID_ARG_TYPE';\n        throw error;\n      }\n\n      return this._createRequireImplementation({\n        children: [],\n        exports: {},\n        filename,\n        id: filename,\n        loaded: false,\n        path: path().dirname(filename)\n      });\n    }; // should we implement the class ourselves?\n\n    class Module extends nativeModule().Module {}\n\n    Object.entries(nativeModule().Module).forEach(([key, value]) => {\n      // @ts-expect-error\n      Module[key] = value;\n    });\n    Module.Module = Module;\n\n    if ('createRequire' in nativeModule()) {\n      Module.createRequire = createRequire;\n    }\n\n    if ('createRequireFromPath' in nativeModule()) {\n      Module.createRequireFromPath = function createRequireFromPath(filename) {\n        if (typeof filename !== 'string') {\n          const error = new TypeError(\n            `The argument 'filename' must be string. Received '${filename}'.${\n              filename instanceof _url().URL\n                ? ' Use createRequire for URL filename.'\n                : ''\n            }`\n          ); // @ts-expect-error\n\n          error.code = 'ERR_INVALID_ARG_TYPE';\n          throw error;\n        }\n\n        return createRequire(filename);\n      };\n    }\n\n    if ('syncBuiltinESMExports' in nativeModule()) {\n      Module.syncBuiltinESMExports = function syncBuiltinESMExports() {};\n    }\n\n    this._moduleImplementation = Module;\n    return Module;\n  }\n\n  _generateMock(from, moduleName) {\n    const modulePath =\n      this._resolver.resolveStubModuleName(from, moduleName) ||\n      this._resolveModule(from, moduleName);\n\n    if (!this._mockMetaDataCache.has(modulePath)) {\n      // This allows us to handle circular dependencies while generating an\n      // automock\n      this._mockMetaDataCache.set(\n        modulePath,\n        this._moduleMocker.getMetadata({}) || {}\n      ); // In order to avoid it being possible for automocking to potentially\n      // cause side-effects within the module environment, we need to execute\n      // the module in isolation. This could cause issues if the module being\n      // mocked has calls into side-effectful APIs on another module.\n\n      const origMockRegistry = this._mockRegistry;\n      const origModuleRegistry = this._moduleRegistry;\n      this._mockRegistry = new Map();\n      this._moduleRegistry = new Map();\n      const moduleExports = this.requireModule(from, moduleName); // Restore the \"real\" module/mock registries\n\n      this._mockRegistry = origMockRegistry;\n      this._moduleRegistry = origModuleRegistry;\n\n      const mockMetadata = this._moduleMocker.getMetadata(moduleExports);\n\n      if (mockMetadata == null) {\n        throw new Error(\n          `Failed to get mock metadata: ${modulePath}\\n\\n` +\n            `See: https://jestjs.io/docs/manual-mocks.html#content`\n        );\n      }\n\n      this._mockMetaDataCache.set(modulePath, mockMetadata);\n    }\n\n    return this._moduleMocker.generateFromMetadata(\n      // added above if missing\n      this._mockMetaDataCache.get(modulePath)\n    );\n  }\n\n  _shouldMock(from, moduleName) {\n    const explicitShouldMock = this._explicitShouldMock;\n\n    const moduleID = this._resolver.getModuleID(\n      fromEntries(this._virtualMocks),\n      from,\n      moduleName\n    );\n\n    const key = from + path().delimiter + moduleID;\n\n    if (explicitShouldMock.has(moduleID)) {\n      // guaranteed by `has` above\n      return explicitShouldMock.get(moduleID);\n    }\n\n    if (\n      !this._shouldAutoMock ||\n      this._resolver.isCoreModule(moduleName) ||\n      this._shouldUnmockTransitiveDependenciesCache.get(key)\n    ) {\n      return false;\n    }\n\n    if (this._shouldMockModuleCache.has(moduleID)) {\n      // guaranteed by `has` above\n      return this._shouldMockModuleCache.get(moduleID);\n    }\n\n    let modulePath;\n\n    try {\n      modulePath = this._resolveModule(from, moduleName);\n    } catch (e) {\n      const manualMock = this._resolver.getMockModule(from, moduleName);\n\n      if (manualMock) {\n        this._shouldMockModuleCache.set(moduleID, true);\n\n        return true;\n      }\n\n      throw e;\n    }\n\n    if (this._unmockList && this._unmockList.test(modulePath)) {\n      this._shouldMockModuleCache.set(moduleID, false);\n\n      return false;\n    } // transitive unmocking for package managers that store flat packages (npm3)\n\n    const currentModuleID = this._resolver.getModuleID(\n      fromEntries(this._virtualMocks),\n      from\n    );\n\n    if (\n      this._transitiveShouldMock.get(currentModuleID) === false ||\n      (from.includes(NODE_MODULES) &&\n        modulePath.includes(NODE_MODULES) &&\n        ((this._unmockList && this._unmockList.test(from)) ||\n          explicitShouldMock.get(currentModuleID) === false))\n    ) {\n      this._transitiveShouldMock.set(moduleID, false);\n\n      this._shouldUnmockTransitiveDependenciesCache.set(key, true);\n\n      return false;\n    }\n\n    this._shouldMockModuleCache.set(moduleID, true);\n\n    return true;\n  }\n\n  _createRequireImplementation(from, options) {\n    const resolve = (moduleName, resolveOptions) => {\n      const resolved = this._requireResolve(\n        from.filename,\n        moduleName,\n        resolveOptions\n      );\n\n      if (\n        (resolveOptions === null || resolveOptions === void 0\n          ? void 0\n          : resolveOptions[OUTSIDE_JEST_VM_RESOLVE_OPTION]) &&\n        (options === null || options === void 0\n          ? void 0\n          : options.isInternalModule)\n      ) {\n        return (0, _helpers.createOutsideJestVmPath)(resolved);\n      }\n\n      return resolved;\n    };\n\n    resolve.paths = moduleName =>\n      this._requireResolvePaths(from.filename, moduleName);\n\n    const moduleRequire = (\n      options === null || options === void 0 ? void 0 : options.isInternalModule\n    )\n      ? moduleName => this.requireInternalModule(from.filename, moduleName)\n      : this.requireModuleOrMock.bind(this, from.filename);\n    moduleRequire.extensions = Object.create(null);\n    moduleRequire.resolve = resolve;\n\n    moduleRequire.cache = (() => {\n      // TODO: consider warning somehow that this does nothing. We should support deletions, anyways\n      const notPermittedMethod = () => true;\n\n      return new Proxy(Object.create(null), {\n        defineProperty: notPermittedMethod,\n        deleteProperty: notPermittedMethod,\n        get: (_target, key) =>\n          typeof key === 'string' ? this._moduleRegistry.get(key) : undefined,\n\n        getOwnPropertyDescriptor() {\n          return {\n            configurable: true,\n            enumerable: true\n          };\n        },\n\n        has: (_target, key) =>\n          typeof key === 'string' && this._moduleRegistry.has(key),\n        ownKeys: () => Array.from(this._moduleRegistry.keys()),\n        set: notPermittedMethod\n      });\n    })();\n\n    Object.defineProperty(moduleRequire, 'main', {\n      enumerable: true,\n      value: this._mainModule\n    });\n    return moduleRequire;\n  }\n\n  _createJestObjectFor(from) {\n    const disableAutomock = () => {\n      this._shouldAutoMock = false;\n      return jestObject;\n    };\n\n    const enableAutomock = () => {\n      this._shouldAutoMock = true;\n      return jestObject;\n    };\n\n    const unmock = moduleName => {\n      const moduleID = this._resolver.getModuleID(\n        fromEntries(this._virtualMocks),\n        from,\n        moduleName\n      );\n\n      this._explicitShouldMock.set(moduleID, false);\n\n      return jestObject;\n    };\n\n    const deepUnmock = moduleName => {\n      const moduleID = this._resolver.getModuleID(\n        fromEntries(this._virtualMocks),\n        from,\n        moduleName\n      );\n\n      this._explicitShouldMock.set(moduleID, false);\n\n      this._transitiveShouldMock.set(moduleID, false);\n\n      return jestObject;\n    };\n\n    const mock = (moduleName, mockFactory, options) => {\n      if (mockFactory !== undefined) {\n        return setMockFactory(moduleName, mockFactory, options);\n      }\n\n      const moduleID = this._resolver.getModuleID(\n        fromEntries(this._virtualMocks),\n        from,\n        moduleName\n      );\n\n      this._explicitShouldMock.set(moduleID, true);\n\n      return jestObject;\n    };\n\n    const setMockFactory = (moduleName, mockFactory, options) => {\n      this.setMock(from, moduleName, mockFactory, options);\n      return jestObject;\n    };\n\n    const clearAllMocks = () => {\n      this.clearAllMocks();\n      return jestObject;\n    };\n\n    const resetAllMocks = () => {\n      this.resetAllMocks();\n      return jestObject;\n    };\n\n    const restoreAllMocks = () => {\n      this.restoreAllMocks();\n      return jestObject;\n    };\n\n    const _getFakeTimers = () => {\n      if (\n        !(this._environment.fakeTimers || this._environment.fakeTimersModern)\n      ) {\n        this._logFormattedReferenceError(\n          'You are trying to access a property or method of the Jest environment after it has been torn down.'\n        );\n\n        process.exitCode = 1;\n      }\n\n      return this._fakeTimersImplementation;\n    };\n\n    const useFakeTimers = (type = 'legacy') => {\n      if (type === 'modern') {\n        this._fakeTimersImplementation = this._environment.fakeTimersModern;\n      } else {\n        this._fakeTimersImplementation = this._environment.fakeTimers;\n      }\n\n      this._fakeTimersImplementation.useFakeTimers();\n\n      return jestObject;\n    };\n\n    const useRealTimers = () => {\n      _getFakeTimers().useRealTimers();\n\n      return jestObject;\n    };\n\n    const resetModules = () => {\n      this.resetModules();\n      return jestObject;\n    };\n\n    const isolateModules = fn => {\n      this.isolateModules(fn);\n      return jestObject;\n    };\n\n    const fn = this._moduleMocker.fn.bind(this._moduleMocker);\n\n    const spyOn = this._moduleMocker.spyOn.bind(this._moduleMocker);\n\n    const setTimeout = timeout => {\n      if (this._environment.global.jasmine) {\n        this._environment.global.jasmine._DEFAULT_TIMEOUT_INTERVAL = timeout;\n      } else {\n        // @ts-expect-error: https://github.com/Microsoft/TypeScript/issues/24587\n        this._environment.global[testTimeoutSymbol] = timeout;\n      }\n\n      return jestObject;\n    };\n\n    const retryTimes = numTestRetries => {\n      // @ts-expect-error: https://github.com/Microsoft/TypeScript/issues/24587\n      this._environment.global[retryTimesSymbol] = numTestRetries;\n      return jestObject;\n    };\n\n    const jestObject = {\n      addMatchers: matchers =>\n        this._environment.global.jasmine.addMatchers(matchers),\n      advanceTimersByTime: msToRun =>\n        _getFakeTimers().advanceTimersByTime(msToRun),\n      advanceTimersToNextTimer: steps =>\n        _getFakeTimers().advanceTimersToNextTimer(steps),\n      autoMockOff: disableAutomock,\n      autoMockOn: enableAutomock,\n      clearAllMocks,\n      clearAllTimers: () => _getFakeTimers().clearAllTimers(),\n      createMockFromModule: moduleName => this._generateMock(from, moduleName),\n      deepUnmock,\n      disableAutomock,\n      doMock: mock,\n      dontMock: unmock,\n      enableAutomock,\n      fn,\n      genMockFromModule: moduleName => this._generateMock(from, moduleName),\n      getRealSystemTime: () => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers instanceof _fakeTimers().ModernFakeTimers) {\n          return fakeTimers.getRealSystemTime();\n        } else {\n          throw new TypeError(\n            'getRealSystemTime is not available when not using modern timers'\n          );\n        }\n      },\n      getTimerCount: () => _getFakeTimers().getTimerCount(),\n      isMockFunction: this._moduleMocker.isMockFunction,\n      isolateModules,\n      mock,\n      requireActual: this.requireActual.bind(this, from),\n      requireMock: this.requireMock.bind(this, from),\n      resetAllMocks,\n      resetModuleRegistry: resetModules,\n      resetModules,\n      restoreAllMocks,\n      retryTimes,\n      runAllImmediates: () => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers instanceof _fakeTimers().LegacyFakeTimers) {\n          fakeTimers.runAllImmediates();\n        } else {\n          throw new TypeError(\n            'runAllImmediates is not available when using modern timers'\n          );\n        }\n      },\n      runAllTicks: () => _getFakeTimers().runAllTicks(),\n      runAllTimers: () => _getFakeTimers().runAllTimers(),\n      runOnlyPendingTimers: () => _getFakeTimers().runOnlyPendingTimers(),\n      runTimersToTime: msToRun => _getFakeTimers().advanceTimersByTime(msToRun),\n      setMock: (moduleName, mock) => setMockFactory(moduleName, () => mock),\n      setSystemTime: now => {\n        const fakeTimers = _getFakeTimers();\n\n        if (fakeTimers instanceof _fakeTimers().ModernFakeTimers) {\n          fakeTimers.setSystemTime(now);\n        } else {\n          throw new TypeError(\n            'setSystemTime is not available when not using modern timers'\n          );\n        }\n      },\n      setTimeout,\n      spyOn,\n      unmock,\n      useFakeTimers,\n      useRealTimers\n    };\n    return jestObject;\n  }\n\n  _logFormattedReferenceError(errorMessage) {\n    const originalStack = new ReferenceError(errorMessage).stack\n      .split('\\n') // Remove this file from the stack (jest-message-utils will keep one line)\n      .filter(line => line.indexOf(__filename) === -1)\n      .join('\\n');\n    const {message, stack} = (0, _jestMessageUtil().separateMessageFromStack)(\n      originalStack\n    );\n    console.error(\n      `\\n${message}\\n` +\n        (0, _jestMessageUtil().formatStackTrace)(stack, this._config, {\n          noStackTrace: false\n        })\n    );\n  }\n\n  wrapCodeInModuleWrapper(content) {\n    return this.constructModuleWrapperStart() + content + '\\n}});';\n  }\n\n  constructModuleWrapperStart() {\n    const args = this.constructInjectedModuleParameters();\n    return '({\"' + EVAL_RESULT_VARIABLE + `\":function(${args.join(',')}){`;\n  }\n\n  constructInjectedModuleParameters() {\n    return [\n      'module',\n      'exports',\n      'require',\n      '__dirname',\n      '__filename',\n      'global',\n      this._config.injectGlobals ? 'jest' : undefined,\n      ...this._config.extraGlobals\n    ].filter(notEmpty);\n  }\n\n  handleExecutionError(e, module) {\n    const moduleNotFoundError = _jestResolve().default.tryCastModuleNotFoundError(\n      e\n    );\n\n    if (moduleNotFoundError) {\n      if (!moduleNotFoundError.requireStack) {\n        moduleNotFoundError.requireStack = [module.filename || module.id];\n\n        for (let cursor = module.parent; cursor; cursor = cursor.parent) {\n          moduleNotFoundError.requireStack.push(cursor.filename || cursor.id);\n        }\n\n        moduleNotFoundError.buildMessage(this._config.rootDir);\n      }\n\n      throw moduleNotFoundError;\n    }\n\n    throw e;\n  }\n\n  getGlobalsForCjs(from) {\n    const jest = this.jestObjectCaches.get(from);\n    invariant(jest, 'There should always be a Jest object already');\n    return {...this.getGlobalsFromEnvironment(), jest};\n  }\n\n  getGlobalsForEsm(from, context) {\n    let jest = this.jestObjectCaches.get(from);\n\n    if (!jest) {\n      jest = this._createJestObjectFor(from);\n      this.jestObjectCaches.set(from, jest);\n    }\n\n    const globals = {...this.getGlobalsFromEnvironment(), jest};\n    const module = new (_vm().SyntheticModule)(\n      Object.keys(globals),\n      function () {\n        Object.entries(globals).forEach(([key, value]) => {\n          // @ts-expect-error: TS doesn't know what `this` is\n          this.setExport(key, value);\n        });\n      },\n      {\n        context,\n        identifier: '@jest/globals'\n      }\n    );\n    return evaluateSyntheticModule(module);\n  }\n\n  getGlobalsFromEnvironment() {\n    if (this.jestGlobals) {\n      return {...this.jestGlobals};\n    }\n\n    return {\n      afterAll: this._environment.global.afterAll,\n      afterEach: this._environment.global.afterEach,\n      beforeAll: this._environment.global.beforeAll,\n      beforeEach: this._environment.global.beforeEach,\n      describe: this._environment.global.describe,\n      expect: this._environment.global.expect,\n      fdescribe: this._environment.global.fdescribe,\n      fit: this._environment.global.fit,\n      it: this._environment.global.it,\n      test: this._environment.global.test,\n      xdescribe: this._environment.global.xdescribe,\n      xit: this._environment.global.xit,\n      xtest: this._environment.global.xtest\n    };\n  }\n\n  readFile(filename) {\n    let source = this._cacheFS.get(filename);\n\n    if (!source) {\n      source = fs().readFileSync(filename, 'utf8');\n\n      this._cacheFS.set(filename, source);\n    }\n\n    return source;\n  }\n\n  setGlobalsForRuntime(globals) {\n    this.jestGlobals = globals;\n  }\n}\n\n_defineProperty(Runtime, 'shouldInstrument', _transform().shouldInstrument);\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nfunction notEmpty(value) {\n  return value !== null && value !== undefined;\n}\n\nasync function evaluateSyntheticModule(module) {\n  await module.link(() => {\n    throw new Error('This should never happen');\n  });\n  await module.evaluate();\n  return module;\n}\n\nmodule.exports = Runtime;\n"]},"metadata":{},"sourceType":"script"}