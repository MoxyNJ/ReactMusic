 ![image-20211025232137631](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211025232137631.png)



# 1 基本

## 1.1 项目规范

1. 文件夹、文件名统一小写，多个单词以连接符（-）链接；
2. JavaScript 变量名称采用小驼峰标识，常量全部使用大写字母，组件采用大驼峰；

 ![image-20211026101035380](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211026101035380.png)

![image-20211026101716474](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211026101716474.png)

# 第一节课 23.

## 步骤一：初始化

### 步骤1.1 目录划分：

创建目录结构

assets ----------  资源

- css --------- CSS资源
- img -------- 图片资源

pages ----------- 页面

components -- 共享组件

router ----------- 路由配置

store ------------- 存放 redux

services --------- 网络请求

utils --------------- 自己封装的工具

common -------- 存放公共常量、数据



### 步骤1.2 CSS重置 + 公共CSS抽取：

**CSS重置：**消除浏览器默认的自带样式。

1. 在 gitbub 上，`reset.css` 和 `normalize-css`（更常用）；
2. 页面：[necolas/normalize.css: A modern alternative to CSS resets (github.com)](https://github.com/necolas/normalize.css)
3. 加入：`npm install --save normalize.css`
4. 然后在文件：`"./assets/css/reset.css";` 中引入 `normalize.css`，方式：`@import "~normalize.css";`。

 ![image-20211026204353038](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211026204353038.png)



**公共CSS抽取：**项目中多个页面都会运用的 CSS 格式，需要集中抽取到这个文件中。未来想对某个元素施加公共样式，直接添加对应的 `class` 名称即可。

- 比如，页面的宽度都相同，图片都有相同的背景色，按钮的宽度相同等等。



最终，文件全部保存在 CSS 的 reset.css 中，图片资源放在 img 文件中。



### 步骤1.3 配置别名

路径过长时，通过配置路径别名，可以简化地址长度。

1. 修改 `webpack` 配置，输入：`yarn add @craco/craco`

2. 修改 `webpack.json` 配置：

   ```json
   "scripts": {
       "start": "craco start",
       "build": "craco build",
       "test": "craco test",
       "eject": "react-scripts eject"
   },
   ```

3. 创建：`craco.config.js`

   ```js
   const path = require("path");
   
   const resolve = (dir) => path.resolve(__dirname, dir);
   
   module.exports = {
     webpack: {
       alias: {
         "@": resolve("src"),
         components: resolve("src/components"),
       },
     },
   };
   ```



最终，不需要输入 `src`，直接通过 `@` 即可快速定位到 `src` 文件夹，缩短了 path 长度。



### 步骤1.4 插曲

配置 Vscode 插件，已经配置好了，放在了 `Settings Sync`  的 GIST 中。

如果需要在其他平台同步插件，需要先下载  `Settings Sync`  ，然后通过 github 登录我的账号，然后：

- `Shift + Alt + D` 下载配置

- `Shift + Alt + U` 上传配置



## 步骤二：页面划分

### 步骤2.1 分析参考页面

对参考页面的基本结构进行划分：

![image-20211026210803381](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211026210803381.png)

App 进行划分：

头 ：AppHeader、

尾：AppFooter、

中间就是一个个切换的路由，我们通过对 AppHeader 中设置按钮，切换中间的不同组件。



### 步骤2.2 文件和组件创建

对拆分好的页面进行文件夹和组件的创建。

- 创建组件
- 创建路由
  - `yarn add react-router-dom`
  - `yarn add react-router-config`

![image-20211026214952888](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211026214952888.png)

此时效果：

点击上方，可以切换中间的内容。

 ![image-20211026215007134](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211026215007134.png)



## 步骤三：为组件添加 CSS

键入：`yarn add styled-components`



## 步骤四：制作 app-header 和 app-footer

- `app-header` 和 `app-footer` 各自有一个 `index.js` 和 `style.js`



#### 问题1：

![image-20211027092922807](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211027092922807.png)

不能和原版一样，使用 require 引入图片，必须要在开头 import 然后使用图片。

- 报错：

![image-20211027093002936](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211027093002936.png)



#### 问题2：

带有 logo 通过一个 `a` 标签包裹，点击后会跳转主页。

 ![image-20211027133444585](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211027133444585.png)

但其中是没有内容的，就会有如下警告：

 ![image-20211027133342356](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211027133342356.png)

常用的解决方案：

1. 在 `a` 标签中添加上方便搜索引擎抓取信息的内容，如：“网易云音乐”；
2. 在 css 中设置 `text-indent: -99999px;` 把文字挤到最左边，超出屏幕，即可解决这个问题。

 ![image-20211027133635242](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211027133635242.png)



# 第二节课：24.

## 步骤五：发现音乐页面



网易云音乐API：[Binaryify/网易云音乐](https://github.com/Binaryify/NeteaseCloudMusicApi)

![image-20211027142504068](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211027142504068.png)



### 步骤5.1：页面整体路由的优化

![image-20211027144550177](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211027144550177.png)

效果：点击网易云音乐的logo，或者在地址栏输入：`localhost:3000` 会发生重定向，自动导航到 `localhost:3000/#/discover` 展示 discover 组件的内容。

 ![image-20211027144508027](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211027144508027.png)



### 步骤5.2：制作discover 页面（1）

制作 discover 的 Header

![image-20211027152300048](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211027152300048.png)

```js
const routes = [
  {
    path: "/",
    exact: true,
    // component: LJDiscover,
    // 设置重定向到 discover
    render: () => <Redirect to="/discover" />,
  },
  {
    path: "/discover",
    component: LJDiscover,
    routes: [
      {
        path: "/discover",
        exact: true,
        render: () => <Redirect to="/discover/recommend" />,
      },
      {
        path: "/discover/recommend",
        component: LJRecommend,
      },
      {
        path: "/discover/ranking",
        component: LJRanking,
      },
      {
        path: "/discover/songs",
        component: LJSongs,
      },
      {
        path: "/discover/djradio",
        component: LJDjradio,
      },
      {
        path: "/discover/artist",
        component: LJArtist,
      },
      {
        path: "/discover/album",
        component: LJAlbum,
      },
    ],
  },
// ..... .....
```



### 步骤5.3 引入 axois 和封装

services 文件夹中：

- `config.js`
- `request.js`

```js
// config.js
const devBaseURL = "http://123.207.32.32:9001";
const proBaseURL = "http://123.207.32.32:9001";
export const BASE_URL =
  process.env.NODE_ENV === "development" ? devBaseURL : proBaseURL;

export const TIMEOUT = 5000;

//request.js
import axios from "axios";

import { BASE_URL, TIMEOUT } from "./config";

const instance = axios.create({
  baseURL: BASE_URL,
  timeout: TIMEOUT,
});

instance.interceptors.request.use(
  (config) => {
    // 1.发送网络请求时, 在界面的中间位置显示Loading的组件
    // 2.某一些请求要求用户必须携带token, 如果没有携带, 那么直接跳转到登录页面
    // 3.params/data序列化的操作
    return config;
  },
  (err) => {}
);

instance.interceptors.response.use(
  (res) => {
    return res.data;
  },
  (err) => {
    if (err && err.response) {
      switch (err.response.status) {
        case 400:
          console.log("请求错误");
          break;
        case 401:
          console.log("未授权访问");
          break;
        default:
          console.log("其他错误信息");
      }
    }
    return err;
  }
);

export default instance;
```



### 步骤5.4 引入 redux 去管理 axios 数据

reducer 要进行拆分：

- 推荐页面的全部数据，都是从服务器请求的，放入一个 recommend 的一个 reducer中；
- 排行榜放入一个 reducer 中；
- 歌单放入一个 reducer 中；
- 主播电台放入一个 reducer 中；
- 歌手放入一个 reducer 中；
- 新碟上架放入一个 reducer 中。

引入 redux-devtools：redux 的调试工具

结果：02_src引入redux

![image-20211027170831818](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211027170831818.png)



### 步骤5.5 引入 redux hooks 解决 connect 的繁琐

问题：

使用 connect 可以让组件快租获取到 store 中的 state 数据和 dispatch 派发方法：

```jsx
function LJRecommend(props) {
  const { getBanners, topBanners } = props;

  useEffect(() => {
    getBanners();
  }, [getBanners]);

  return (
    <div>
      <h2>LJRecommend</h2>
      <h2>{topBanners.length} </h2>
    </div>
  );
}

// 拿到的是最外层的state，store中全部的state
const mapStateToProps = (state) => ({
  topBanners: state.recommend.topBanners,
});

// 拿到了store的dispatch方法
const mapDispatchToProps = (dispatch) => ({
  getBanners: () => {
    dispatch(getTopBannerAction());
  },
});

// 最终渲染的是这个组件，这个组件内部包含了LJRecommend组件
// 每次重新渲染LJRecommend，实际上是先渲染下面这个组件
// 下面这个组件一旦渲染，mapStateToProps 和 mapDispatchToProps 会重新获取
// 为什么要重新获取？因为要保持state和dispatch的数据最新
// 重新获取后，mapDispatchToProps中的getBanners就发生改变
// getBanners就发生改变后，useEffect内的代码就会被执行
// 代码被执行后，就会调用异步Action，获取topBanners的数据
// 获取到数据后，就会dispatch更新到stroe中。
export default connect(mapStateToProps, mapDispatchToProps)(memo(LJRecommend));
```

但是依然非常繁琐，需要 `mapStateToProps` 和 `mapDispatchToProps`的定义，以及 `connect` 方法的包裹。



#### 解决：

redux hooks 解决了组件获取 redux 中 state 数据和 dispatch 派发方法的问题。不再需要 connect 的繁琐流程。

- `useSelector` 获取 state
- `useDispatch` 获取 dispatch

```jsx
import React, { memo, useEffect } from "react";
import { useDispatch, useSelector, shallowEqual } from "react-redux";
import { getTopBannerAction } from "./store/actionCreators";
function LJRecommend(props) {
  // 利用 redux hooks
  // 组件和redux关联：获取数据state和操作的XXXAction

  // ---- 24课：02：10：00
  // 拿到stata方式
  // 两个参数：回调函数 +
  // ---- 回调函数
  // ---- 回调函数有一个参数 state，就是store的全部state
  // ---- 这个回调函数会有一个返回值，这个返回值会赋值给左侧的变量 *里面*。
  // ---- 左侧变量接内接受到这个属性，然后通过解构赋值，直接拿到。
  // ----
  // ---- 性能优化
  // ---- connect的mapStateToProps会把state和组件形成依赖，进而如果依赖的数据没有改变，这个组件也不会被重新渲染，节约开销
  // ---- 但是使用useSelector如果只传入第一个参数，就不会有这种浅对比，只要有state发生变化，就会重新渲染组件。
  // ---- useSelector使用的是“===”来比较，但是每次返回的有state的对象，都是新创建的，所以一定不相等，一定会重新渲染。
  // ---- 解决方案：shallowEqual的引入
  // ---- 直接传入 shallowEqual 为第二个参数即可。
  // ---- 理论上，只要使用 useSelector，就需要传入 shallowEqual，除非希望一旦state变化，组件要重新渲染的时候不传入。
  const { topBanners } = useSelector(
    (state) => ({
      topBanners: state.recommend.topBanners,
    }),
    shallowEqual
  );

  // 拿到dispatch方式
  const dispatch = useDispatch();

  // 发送网络请求
  // 依赖：一般不会发生dispatth改变，但保险起见，加上依赖。
  // ------ 因为dispatch发生改变，需要页面重新渲染
  useEffect(() => {
    console.log(dispatch);
    dispatch(getTopBannerAction());
  }, [dispatch]);

  return (
    <div>
      <h2>LJRecommend</h2>
      <h2>{topBanners.length}</h2>
    </div>
  );
}

export default memo(LJRecommend);
```



# 第三节课：25.

## 步骤六：发现音乐页面

### 步骤6.1 Immutable JS性能优化

#### 问题：

数据应当具有不可变性，reducer 应当是一个纯函数，不能修改数据。

recommend 组件中，有非常多的数据：

排行榜、歌手列表、歌曲列表、歌单列表等等

现在的代码中，一旦发生数据更新，recommend 中所有的 state 数据都要浅拷贝一份，然后创建好一个新的 state，这样非常影响性能。

- reducer 是一个纯函数：

  ```jsx
  function reducer(state = defaultState, action) {
    switch (action.type) {
      case actionTypes.CHANGE_TOP_BANNERS:
        return { ...state, topBanners: action.topBanners };
      default:
        return state;
    }
  }
  ```

 

#### 解决：

既能 **保持数据不可变性**，又能 **节省内存，不要整个拷贝** 。

引入一个新的库解决 —— **ImmutableJS**

- ImmutableJS 对象的特点是，只要修改了对象，就会返回一个新的对象，旧的对象不会改变。
- ImmutableJS  使用了 Persistent Data Structure（持久化数据结构，或一致性数据结构）
  - 这是一种保存数据的数据结构
  - 当数据被修改时，会返回一个对象，但是返回的这个新对象会 **尽可能** 利用之前的数据结构，尽可能的节省内存。

一张图模拟这个过程：

<img src="%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/cb76e970eab64972905250166406af8etplv-k3u1fbpfcp-watermark.awebp" alt="immutable修改节点更新引用过程" style="zoom:67%;" />

即使一个对象



使用：

```jsx
// 创建一个 Immutable
const im = Immutable;					

// Map的使用
const info = { name: "Moxy", age:18 };  // 普通对象
const infoIM = im.Map(info)   // im.Map 转化为一个 immutable对象

const obj = infoIM;
const infoIM2 = infoIM.set("name", "Ninjee")  // 对 immutable对象 进行数据修改。
											// obj没有影响，infoIM2 生成一个新对象
obj.get("name")				// 	获取数据


// list使用
const names = ["Moxy", "Ninjee", "Mon"];	//	普通数组
const namesIM = im.List()	// im.List 转化为一个 immutable数组
			
const arr = namesIM.set(0, "Hello")  	// 按下标修改数据
										// namesIM 没有影响，arr 生成了一个数组。
namesIM.get(0)		// 按下标获取数据

```

- `const im = Immutable`：创建 Immutable 
- `Map()`、`List()`：创建映射、创建列表。
  - `Map()` 只是浅层转化，如果成员仍然是一个对象，这个成员是一个普通对象。
- `im.fromJS(obj)`：深层转化。如果有多层嵌套的对象，使用这个方法可以把内部嵌套的对象都转化为一个 immutable 对象。
- `get()` ：获取数据
- `set()` ：修改数据
- `state.getIn(["recommend", "topBanners"])` ：向内层获取数据，传入的是可迭代的对象。
  - 这段代码的意思是：`state` 是一个 `immutable` 对象，获取它成员 `recommend` 的数据；然后这个 `recommend` 也是一个 `immutable` 对象，继续获取它的成员 `topBanners` 的数据。
  - 相当于：`state.get("recommend").("topBanners")`

#### 应用：

导入：`yarn add immutable`

1. 把每一个模块的 `reducer` 中，`defaultState` 都包裹一个 Immutable，都转化成 Immutable 对象。

```jsx
// 引入 Map，这里没有用 FromJS
import { Map } from "immutable";

import * as actionTypes from "./constants";

// 转化为 immutable对象
const defaultState = Map({
  topBanners: [],
});

function reducer(state = defaultState, action) {
  switch (action.type) {
    case actionTypes.CHANGE_TOP_BANNERS:
       		//	set方法返回一个新的immutable对象，reduxer依然是纯函数。
      return state.set("topBanners", action.topBanners);
    default:
      return state;
  }
}

export default reducer;
```

2. 使用 immutable 对象的数据

```jsx
const { topBanners } = useSelector(
    (state) => ({
        // 使用时，使用 get 获取数据
        topBanners: state.recommend.get("topBanners"),
    }),shallowEqual
);
```



#### redux-immutable

导入：`yarn add redux-immutable`

我们知道，在 redux 中，当 reducer 内容过多的时候，可以根据不同 page、或者不同功能对 reducer 进行拆分。然后利用 `combineReducers()`  进行合并。

- `combineReducers` 需要传入一个对象，这个对象的成员就是所有子 reducer 的集合。
- `combineReducers` 返回了一个综合的 `reducer` ，这个 `reducer` 内部有 `combineReducers` 自己的使用逻辑。所以我们没办法把它简单粗暴的转化为 `immutable` 对象。

这时，就需要引入 `redux-immutable` 去解决这个问题了。

```jsx
// import { combineReducers } from "redux";
import { combineReducers } from "redux-immutable";

import { reducer as recommendReducer } from "../pages/discover/c-pages/recommend/store";

// 对所以组件的 reducer 进行融合
const cReducer = combineReducers({
  recommend: recommendReducer,
});

export default cReducer;
```

原本是从 `redux` 中获取的 `combineReducers`，现在从 `redux-immutable` 中获取。

这样，通过 `combineReducers` 方法返回的这个大 `reducer`，既是一个 `immutable` 对象，也是一个 `combineReducers` 对象了。

因为最外层的 state也是一个 immutable 对象了，所以获取 state 的方式需要改变：

```jsx
// 拿到state
const { topBanners } = useSelector(
    (state) => ({
        // 两种方法都可以，第二种更直观。
        // topBanners: state.get("recommend").get("topBanners"),
        topBanners: state.getIn(["recommend", "topBanners"]),
    }),
    shallowEqual
);
```



## 步骤6.2 Banner 轮播图

Andt 的轮播图：[走马灯 Carousel - Ant Design](https://ant.design/components/carousel-cn/)

背景模糊：

1. styled-component 的使用：

```jsx
export const BannerWrapper = styled.div`
  /* 可以通过 props 从组件中接收参数，然后使用 */
  background: url(${(props) => props.bgImage}) center center/6000px;

  .banner {
    height: 270px;
    background-color: red;

    display: flex;
    position: relative;
  }
`;
```

2. 使用

```jsx
// 保存一下当前图片下标
const [currentIndex, setCurrentIndex] = useState(0);

// 背景模糊图
  // 使用 useCallback，防止该回调函数每次组件渲染都重定义
  const bannerChange = useCallback((from, to) => {
    // 根据API自身携带了 from 和 to 这两个参数，to 保存了当前图片的下标
    // console.log(to)
    setCurrentIndex(to);
  }, []);

//1 使用 ‘&&’
  // 防止 topBanners 最开始的时候拿不到数据，先判断一下是否有数据：topBanners[currentIndex]
  // 如果有数据，就那其中的 imageURL，如果没数据，就拿到了一个 undefined。
  // 如果拿不到 topBanners，就去找 imageUrl，这就相当于 undefined.imageUrl 会报错
//2 使用 字符串拼接
  // 根据观察原网页， 图片地址+?imageView&blur=40x20 即可生成一个模糊图
  const bgImage =
    topBanners[currentIndex] &&
    topBanners[currentIndex].imageUrl + "?imageView&blur=40x20";
```

3. 补充

```jsx
// 通过标签直接传递给 styled-component，从 porps 就可以获取
<BannerWrapper bgImage={bgImage}>
```



`ref={bannerRef}`：用来控制左右两侧的小箭头

 

## 步骤6.3 热门推荐

组织一个文件的 import 顺序：

```js
// 官方库   		 react、redux、react-redux、
// 第三方库  		 redux-immutable、immutable

// 自定义的封装 		constants、
// 自定义的 reduxActions  getHotRecommendsAction
// 自定义的组件 		LJThemeHeaderRCM、LJSongsCover

// 自定义的 style	 HotRecommendWrapper
```



组织一个组件的内部代码顺序：

```js
  // component state：      组件内部的state

  // redux hooks：          获取state和dispatch

  // other hooks：          react的hooks

  // other function：       组件内部的其他逻辑
```

热门推荐只需要 8 个 item，获取热门推荐的地址是：`http://123.207.32.32:9001/personalized`，经过手动尝试，发现只要后面添加 `?limit=8`，形成地址：`...../personalized?limit=8` 就可以从服务器只返回 8 个 item。

- 所以，在设置 services 时，额外一个 `params` 属性，里面保存了 `limit` 属性。这个属性在赋值后，会随着地址发送至服务器请求数据。会自动的添加在地址的 `"?"` 后面。

```jsx
// url: "/personalized?limit=8",

export function getHotRecommends(limit) {
  return request({
    url: "/personalized",
    params: {
      limit,
    },
  });
}
```



播放量的效果：

- 和网易云相同

![image-20211028191434162](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211028191434162.png)

```jsx
// 音乐的播放量：12亿，35万，4460
export function getCount(count) {
  if (count < 0) return;
  // 小于2万
  if (count < 20000) {
    return count;
    // 小于2亿
  } else if (Math.floor(count / 20000) < 10000) {
    return Math.floor(count / 10000) + "万";
  } else {
    return Math.floor(count / 100000000) + "亿";
  }
}
```

- 如何显示显示小数点，这个技巧记录一下。

![image-20211028191512303](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211028191512303.png)

```jsx
// 音乐的播放量：12.3亿，234.5万，5523
export function getCount(count) {
  if (count < 0) return;
  // 小于2万
  if (count < 20000) {
    return count;
    // 小于2亿
  } else if (Math.floor(count / 20000) < 10000) {
    return Math.floor(count / 10000) + "万";
    // return Math.floor(count / 1000) / 10 + "万";
  } else {
    return Math.floor(count / 100000000) + "亿";
    // return Math.floor(count / 10000000) / 10 + "亿";
  }
}
```



# 第三节课：26.

## 步骤6.4 新碟上架

新碟上架中的专辑封面，在 “新碟上架页面” 中也有，但是两种的尺寸不同，所以组件的 styled 设计要用 props 传递尺寸：

```jsx
.album-image {
    position: relative;
    width: ${(props) => props.width};
    height: ${(props) => props.size};
    overflow: hidden;
    margin-top: 15px;

    img {
        width: ${(props) => props.size};
        height: ${(props) => props.size};
    }
}
```

​         <img src="%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211028220410764.png" alt="image-20211028220410764" style="zoom:80%;" />               <img src="%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211028220426671.png" alt="image-20211028220426671" style="zoom:80%;" />  

- 网页中有两个地方用到专辑封面造型，但是尺寸不同，左边的小，右边的大。



## 步骤6.5 榜单



# 第四节课：27.

## 步骤6.6 右侧三个栏目





## 步骤6.7 底部的播放条

#### 1. 实现垂直居中：

![image-20211029144024466](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211029144024466.png)

```css
left: 50%; 
transform: translateX(-50%);
```

原理：

- `left: 50%; `：元素的尺寸忽略，移动距离是 **包含块宽度** 的一半。是以包含块的左边界为原点，让元素的左边空出包含块宽度的一半。
- `transform: translateX(-50%);`：移动距离是 **元素宽度** 的一半。是以包含块的左边界为原点，让元素向左移动元素宽度的一半。



默认，中间的播放条在最左端

![image-20211029144006260](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211029144006260.png)

添加 `left: 50%; ` 后，播放条右移了 半个网页宽度，

![image-20211029144126247](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211029144126247.png)

添加 `transform: translateX(-50%);` 后，播放条左移了 半个播放条的宽度。

![image-20211029144201213](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211029144201213.png)

总结：

- `left` 的移动距离是参考包含块尺寸的；

- `transform` 的移动距离是参考元素自身的。



#### 2. 播放条

使用的是 antd 中的 Slider。

- https://ant.design/components/slider-cn/





# 第五节课：28.

### 步骤7.1 播放页面

![image-20211101103601495](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211101103601495.png)



```js
const song = res.songs && res.songs[0];
if (!song) return
```

- 为了防止 `res.songs` 是 `undefined` 而导致获取 `res.songs[0]` 时报错。这里要先判断一下 `res.songs` 是否存在，如果存在，则返回 `res.songs[0]`
- 同时，为了防止 `song` 也没有获取到，则用 if 判断一下，如果没有拿到 `song`，则结束函数。















## todo：

![image-20211101190800694](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211101190800694.png)

完善这个页面









# 第六节课：29.

 ![image-20211101205032511](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211101205032511.png)

## 步骤End.1 项目的打包和发布

使用：`yarn build` ，生成 build 文件夹。

![image-20211101215930074](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211101215930074.png)



## 步骤End.2 懒加载

如果项目复杂，体积大时，需要懒加载技术以提升首屏加载速度。

用户需要 “迫不及待” 的打开首屏页面，所以我们减少下载项目文件的体积，分批次的下载。

一个可行的思路就是使用 “懒加载” 方式。当用户进入主页的时候，我们就只加载（下载）主页需要用到的对应资源和文件，用户点击其他页面的时候，我们再加载（下载）对应页面的资源和文件。这样分批次的下载资源，提升了页面响应时间。



#### 改造：

把 router 中，所有路由加载的组件，都是用懒加载的形式：

使用 React 的内置 API：`React.lazy()`

```js
// 原始导入方式：
import LJDiscover from "@/pages/discover";
import LJRecommend from "@/pages/discover/c-pages/recommend";

// 使用 lazy 懒加载
const LJDiscover = lazy(() => import("@/pages/discover"));

// 进一步优化箭头函数的括号为 '_'，写起来更简单
const LJRecommend = lazy( _ => import("@/pages/discover/c-pages/recommend"))
```

同时，在 `App.js` 中对懒加载的组件用 `Suspense` 包裹

```jsx
export default memo(function App() {
  return (
    // 共享 store
    <Provider store={store}>
      <HashRouter>
        <LJAppHeader />
        <Suspense fallback={<h2>Page Loading...</h2>}>
          {renderRoutes(routes)}
        </Suspense>
        <LJAppFooter />
        <LJAppPlayBar />
      </HashRouter>
    </Provider>
  );
});
```

`Suspense`  组件提供了一个辅助页面的帮助：如果懒加载的组件尚未下载完成，为了防止页面空白时间过长，可以添加一个 `fallback` 参数，把备用的组件传递过去，用以提示用户正在加载中。

- 上文中只是传递了一个 `h2` 标签，通常这里会传递一个组件。

![image-20211101224432992](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211101224432992.png)



## 步骤End.3 发布







Player 文件夹下的分类：

- `app-player-bar` ---- 底部 bar 的主体
- `app-player-panel` ---- 底部 bar 的播单页面
- `app-player-volume` ---- 底部 bar 的音量调节
- `c-cpns`  --- 播放全屏页的相关内容
- `index.js`    --- 播放的全屏页面的主体

![image-20211102154806439](%E7%BD%91%E6%98%93%E4%BA%91%E9%A1%B9%E7%9B%AE01/image-20211102154806439.png)



# 小技巧合集：

1.   如何在 render 中使用 if 和 switch？

解决方案：

-   使用 三元运算符代替 if；
-   使用 立即执行函数，在其中可以任意 js 代码；
-   在外部定义一个函数，然后在 jsx 中调用这个函数。



定义一个立即执行箭头函数，注意括号的嵌套：

```jsx
return (
  <div className={classNames("item", { active: isActive })}>
    <span
      onClick={(e) => {
        console.log(item);
        setCurrentAlpha(item);
      }}
      >
      {/* 使用立即执行箭头函数，可以在jsx中用switch */}
      {(() => {
        switch (item) {
          case -1:
            return "全部";
          case 0:
            return "其他";
          default:
            return item.toUpperCase();
        }
      })()}
    </span>
  </div>
);
```



## 技巧2:

阻止事件冒泡：

-   `e.stopPropagation();` 可以阻止事件冒泡，在按钮上使用该函数。就可以让按钮外层的事件监听失效。

```jsx
<button
  className="select"
  onClick={(e) => {
    e.stopPropagation();
    setShowCategory(!showCategory);
  }}
>
```



```jsx
// 外层的事件监听
onClick={(e) => {
  setShowCategory(false);
}}
```

















